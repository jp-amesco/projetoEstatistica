(function () {var a = "'do tipo", k = "SCRIPT", n = "array", p = "função", q = "google.charts.load", t = "hasOwnProperty", u = "número", v = "objeto", w = "pré-45", x = "propertyIsEnumerable", y = "string", z = "texto / javascript", A = "toLocaleString", função B () {retorno function (b) {return b}} função C () {função return () {}} função D (b) {função return () {return this [b]}} função E (b) {função return () { return b}} var F, H = H || {}; H.scope = {};
H.Jq = function (b, c, d) {b instanceof String && (b = String (b)); para (var e = b.length, f = 0; f <e; f ++) {var g = b [ f]; if (c.call (d, g, f, b)) return {Uj: f, Gl: g}} return {Uj: -1, Gl: void 0}}; H.uh =! 1; H.Zl =! 1; H. $ l =! 1; H.defineProperty = H.h || typeof Object.defineProperties == p? Object.defineProperty: function (b, c, d) {b! = Matriz. prototype && b! = Object.prototype && (b [c] = d.value)}; H.Cj = function (b) {retorno "undefined"! = janela type && janela === b? b: "undefined"! = tipo global && null! = global? global: b}; H.global = H.Cj (este);
H.Mk = função (b) {se (b) {para (var = H.global, d = ["Promise"], e = 0; e <d.length-1; e ++) {var f = d [e]; f em c || (c [f] = {}); c = c [f]} d = d [comprimento-1]; e = c [d]; b = b (e) b! = e && null! = b && H.defineProperty (c, d, {configurável:! 0, gravável:! 0, valor: b})}}; H.Xp = função (b, c, d) {if (null == b) lançar novo TypeError ("O valor 'this' para String.prototype." + d + "não deve ser nulo ou indefinido"); if (c instanceof RegExp) lançar novo TypeError ("Primeiro argumento para String.prototype. "+ d +" não deve ser uma expressão regular "); return b +" "};
H.Ci = function (b) {var c = 0; função return () {return c <b.length? {Feito:! 1, valor: b [c ++]}: {feito:! 0}}}; H .Bi = function (b) {return {próximo: H.Ci (b)}}; H.Fg = função (b) {var = "indefinido"! = Typeof Symbol && Symbol.iterator && b [Symbol.iterator]; return c c.call (b): H.Bi (b)}; H.Ph =! 1;
H.Mk (function (b) {função c (b) {this.ba = g.ya; this.la = void 0; this.ub = []; var c = this.fd (); tente {b ( c.resolve, c.reject)} catch (r) {c.reject (r)}} função d () {this.La = null} function e (b) {retorno b instanceof c? b: novo c (função (c) {c (b)})} se (b &&! H.Ph) retornar b; d.prototype.We = function (b) {null == this.La && (this.La = [], this.Gi ()); this.La.push (b)}; d.prototype.Gi = function () {var b = isso; this.Xe (function () {b.oj ()})}; var f = H .global.setTimeout; d.prototype.Xe = function (b) {f (b, 0)}; d.prototype.oj = function () {para (; this.La && this.La.length;) {var b =
this.La; this.La = []; para (var c = 0; c <b.length; ++ c) {var d = b [c]; b [c] = nulo; tente {d ()} catch (G) {this.Hi (G)}}} this.La = null}; d.prototype.Hi = function (b) {this.Xe (function () {lance b;})}; var g = {ya: 0, Ka: 1, nd: 2}; c.prototype.fd = function () {função b (b) {função de retorno (e) {d || (d =! 0, b.call (c) , e)}} var c = this, d =! 1; return {resolver: b (this.Rk), rejeitar: b (this.Rd)}}; c.prototype.Rk = function (b) {se (b === this) this.Rd (new TypeError ("Um Promise não pode resolver para si mesmo")); else if (b instanceof c) this.jl (b); else {a: switch (typeof b) {case v: var d =
null! = b; quebra a; caso p: d =! 0; quebra a; padrão: d =! 1} d? this.Qk (b): this.yf (b)}}; c.prototype.Qk = function (b) {var c = void 0; try {c = b.then} catch (r) {this.Rd (r); retorno} typeof c == p? this.kl (c, b): isto. yf (b)}; c.prototipo.Rd = função (b) {this.Zg (g.na, b)}; c.prototype.yf = função (b) {this.Zg (g.Ka, b) }; c.prototype.Zg = function (b, c) {se (this.ba! = g.ya) erro de lançamento ("Impossível liquidar (" + b + "," + c + "): promessa já estabelecida no estado" + this.ba); this.ba = b; this.la = c; this.qj ()}; c.prototype.qj = function () {if (null! = this.ub) {para (var b = 0; b <this.ub.length; ++ b) h.We (this.ub [b]);
this.ub = null}}; var h = novo d; c.prototype.jl = function (b) {var c = this.fd (); b.dc (c.resolve, c.reject)}; c. prototype.kl = function (b, c) {var d = this.fd (); tente {b.call (c, d.resolve, d.reject)} capturar (G) {d.reject (G)}} c.prototype.then = function (b, d) {função e (b, c) {retorno typeof b == p? função (c) {try {f (b (c))} captura (aa) {g (aa)}}: c} var f, g, h = novo c (função (b, c) {f = b; g = c}); this.dc (e (b, f), e (d, g)); return h}; c.prototype ["catch"] = function (b) {retornar this.then (void 0, b)}; c.prototype.dc = funç˜ao (b, c) {funç˜ao d ( ) {switch (e.ba) {case g.Ka: b (e.la);
case g.na:c(e.la);break;default:throw Error ("Estado inesperado:" + e.ba);}} var e = this; null == this.ub? h.We ( d): this.ub.push (d)}; c.resolve = e; c.reject = function (b) {retornar novo c (função (c, d) {d (b)})}; = function (b) {return new c (função (c, d) {para (var f = H.Fg (b), g = f.next () ;! g.done; g = f.next ()) e (g.value) .dc (c, d)})}; c.all = function (b) {var d = H.Fg (b), f = d.next (); retorno f.done? e ([]): novo c (função (b, c) {função g (c) {função de retorno (d) {h [c] = d; l -; 0 == l && b (h)}} var h = [], l = 0; faça h.push (void 0), l ++, e (f.value) .dc (g (h.length-
1), c), f = d.next (); while (! F.done)})}; return c}); var I = I || {}; I.global = isto; IW = function (b ) {return void 0! == b}; IM = função (b) {retorno typeof b == y}; I.Xj = função (b) {retorno "booleano" == tipo de b}; I.Rb = função (b) {return typeof b == u}; I.ld = função (b, c, d) {b = b.split ("."); d = d || I.global; b [0] in d || "indefinido" == typeof d.execScript || d.execScript ("var" + b [0]); para (var e; b.length && (e = b.shift ());)! b. length && I.W (c)? d [e] = c: d = d [e] && d [e]! == Object.prototype [e]? d [e]: d [e] = {}}; define = função (b, c) {Ild (b, c)}; IZ =! 0; IS = "en";
I.Xc =! 0; I.li =! 1; I.Lh =! IZ; I.Pm =! 1; I.Os = função (b) {if (I.sg ()) erro de lançamento ("goog .provide não pode ser usado dentro de um módulo. "); I.ff (b)}; I.ff = função (b, c) {I.ld (b, c)}; I.Zf = function () {null === I.gd && (I.gd = I.Gj () || ""); return I.gd}; I.Xh = / ^ [\ w + / _-] + [=] {0,2} $ /; I.gd = null; I.Gj = function () {var b = I.global.document; retorno (b = b.querySelector && b.querySelector ("script [nonce]")) && (b = b. nonce || b.getAttribute ("nonce")) && I.Xh.test (b)? b: nulo}; I.ti = / ^ [a-zA-Z _ $] [a-zA-Z0-9._ $] * $ /;
I.uc = function (b) {se (! IM (b) ||! B || -1 == b.search (I.ti)) erro de lançamento ("Invalid module identifier"); if (! I. rg ()) erro de lançamento ("Módulo" + b + "foi carregado incorretamente. Nota, os módulos não podem ser carregados como scripts normais. Eles exigem algum tipo de etapa de pré-processamento. É provável que você esteja tentando carregar um módulo por meio de um script ou como parte de um pacote concatenado sem reescrever o módulo. Para obter mais informações, consulte: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative- para goog.provide. ");
if (I.ia.Sb) erro de lançamento ("goog.module só pode ser chamado uma vez por módulo."); I.ia.Sb = b}; I.uc.get = E (nulo); I.uc. kr = E (nulo); I.Ab = {ve: "es6", Vc: "goog"}; I.ia = nulo; I.sg = funcao () {retorno I.rg () || I.bk ()}; I.rg = function () {return !! I.ia && I.ia.type == I.Ab.Vc}; I.bk = function () {if (I.ia && I.ia.type == I.Ab.ve) return! 0; var b = I.global. $ Jscomp; return b? Typeof b.qd! = P?! 1: !! b.qd () :! 1}; I.uc. hd = function () {I.ia.hd =! 0};
I.j = função (b) {se (I.ia) I.ia.Sb = b; senão {var c = I.global. $ Jscomp; if (! C || tipo de c.qd! = P) Erro ('Módulo com espaço de nomes "' + b + '" foi carregado incorretamente.'); C = c.Ok (c.qd ()); I.Eg [b] = {rj: c, tipo: I.Ab .ve, Jk: b}}}; I.uc.wq = Eujo; I.It = função (b) {se (I.Lh) lançar b = b || "", Erro ("Importando teste- somente código em ambiente não-debug "+ (b?": "+ b:". "));}; I.Pq = C (); I.ob = função (b) {b = b.split (" . "); para (var c = I. global, d = 0; d <b.length; d ++) se (c = c [b [d]] ,! I.bb (c)) retornar nulo; };
I.wr = função (b, c) {c = c || I.global; para (var d em b) c [d] = b [d]}; I.jp = C (); I.mu = ! 1; I.Qm =! 0; I.yk = função (b) {I.global.console && I.global.console.error (b)}; I.Ok = C (); I.at = função () {return {}}; I.Ki = ""; I.cb = C (); I.ip = function () {erro de lançamento ("método abstrato não implementado");}; I.kp = função (b) { b.Ed = void 0; b.jr = function () {if (b.Ed) retorno b.Ed; IZ && (I.kg [I.kg.length] = b); retorno b.Ed = novo b} }; I.kg = []; I.Ln =! 0; I.hi = IZ; I.Eg = {}; I.Bm =! 1; I.Wo = "detectar"; I.Xo = "" ; I.ni = "transpile.js"; I.Cd = nulo;
I.El = function () {if (null == I.Cd) {try {var b =! Eval ('"usar estrito"; vamos x = 1; função f () {retornar tipo de x;}; f ( ) == "número"; ')} captura (c) {b =! 1} I.Cd = b} retorno I.Cd}; I.Ll = função (b) {retorno "(function () {" + b + "\ n;}) (); \ n"};
I.ss = função (b) {var c = I.ia; tente {I.ia = {Sb: "", hd:! 1, tipo: I.Ab.Vc}; se (I.Ba (b) ) var d = b.call (void 0, {}); caso contrário, (IM (b)) I.El () && (b = I.Ll (b)), d = I.vk.call (void 0 , b); caso contrário, lançar Erro ("Definição de módulo inválida"); var e = I.ia.Sb; se (IM (e) && e) I.ia.hd? I.ff (e, d): I.hi && Object .seal && typeof d == v && null! = d && Objeto.seal (d), I.Eg [e] = {rj: d, tipo: I.Ab.Vc, Jk: I.ia.Sb}; caso contrário, lançar Erro ('Inválido nome do módulo "'+ e +'" ');} finalmente {I.ia = c}}; I.vk = função (b) {eval (b); retorno {}};
I.Ds = função (b) {b = b.split ("/"); para (var c = 0; c <b.length;) "." == b [c] b.splice (c, 1): c && ".." == b [c] && b [c-1] && ".."! = B [c-1] b.splice (- c, 2): c ++; retorno b. join ("/")}; I.tk = function (b) {se (I.global.Fh) retornar I.global.Fh (b); tente {var c = novo I.global.XMLHttpRequest; c.open ("get", b,! 1); c.send (); return 0 == c.status || 200 == c.status? c.responseText: null} captura (d) {retorno nulo}};
I.du = function (b, c, d) {var e = I.global. $ Jscomp; e || (I.global. $ Jscomp = e = {}); var f = e.ce; if (! f) {var g = I.Ki + I.ni, h = I.tk (g); se (h) {(function () {eval (h + "\ n // # sourceURL =" + g)}) .call (I.global); if (I.global. $ gwtExport && I.global. $ gwtExport. $ jscomp &&! I.global. $ gwtExport. $ jscomp.transpile) erro de lançamento ('O transpilador não exportou corretamente o transpile "método. $ gwtExport: '+ JSON.stringify (I.global. $ gwtExport)); I.global. $ jscomp.ce = I.global. $ gwtExport. $ jscomp.transpile; e = I.global. $ jscomp ; f = e.ce}} if (! f) {var l = "requer transpilaç˜ao mas nenhum transpilador foi encontrado.";
l + = 'Por favor, adicione "// javascript / closure: transpiler" como uma dependência de dados para garantir que está incluído.'; f = e.ce = função (b, c) {I.yk (c + l); }} return f (b, c, d)};
I.ca = function (b) {var c = tipo de b; if (c == v) if (b) {se (b instanceof Array) retorna n; if (b instanceof Object) retorna c; var d = Object. prototype.toString.call (b); if ("[object Window]" == d) retornar v; if ("[Array do objeto]" == d || typeof b.length == u && "indefinido"! = typeof b.splice && "undefined"! = typeof b.propertyIsEnumerable &&! b.propertyIsEnumerable ("splice")) return n; if ("[objeto Função]" == d || "undefined"! = tipo de b.call && "undefined" ! = typeof b.propertyIsEnumerable &&! b.propertyIsEnumerable ("call")) return p mais retorno "null";
else if (c == p && "indefinido" == typeof b.call) retorno v; retorno c}; I.cs = função (b) {retorno nulo === b}; I.bb = função (b) { return null! = b}; I.isArray = função (b) {return I.ca (b) == n}; I.Nb = função (b) {var = Ica (b); retorno c = = n || c == v && typeof b.length == u}; I.Or = função (b) {retorno I.ka (b) && tipoof b.getFullYear == p}; I.Ba = função (b) { return I.ca (b) == p}; I.ka = função (b) {var c = tipo de b; retorno c == v && nulo! = b || c == p}; I.ag = função (b ) {return b [I.Va] || (b [I.Va] = ++ I.wl)}; I.zr = function (b) {retorno !! b [I.Va]};
I.Nk = function (b) {null! == b && "removeAttribute" em b && b.removeAttribute (I.Va); tente {delete b [I.Va]} capturar (c) {}}; I.Va = " closure_uid _ "+ (1E9 * Math.random () >>> 0); I.wl = 0; I.ir = I.ag; I.Ws = I.Nk; I.Vi = função (b) {var = I.ca (b); if (c == v || c == n) {if (tipo de b.clone === p) retorna b.clone (); c = c == n? []: {}; para (var d em b) c [d] = I.Vi (b [d]); retorno c} retorno b}; I.Mi = função (b, c, d) {retorno b.call. apply (b.bind, argumentos)};
I.Li = função (b, c, d) {se (! B) ataca Erro (); if (2 <argumentos.length) {var e = Array.prototype.slice.call (argumentos, 2); função de retorno () {var d = Array.prototype.slice.call (argumentos); Array.prototype.unshift.apply (d, e); retorno b.apply (c, d)}} função return () {return b.apply (c, argumentos)}}; I.bind = função (b, c, d) {I.bind = Função.prototipo.bind && - 1! = Function.prototype.bind.toString (). indexOf ("código nativo" ) I.Mi: I.Li; return I.bind.apply (nulo, argumentos)};
I.eb = função (b, c) {var d = Array.prototype.slice.call (argumentos, 1); função de retorno () {var c = d.slice (); c.push.apply (c, argumentos ); return b.apply (isto, c)}}; I.ys = função (b, c) {para (var d em c) b [d] = c [d]}; I.now = I.Xc && Date .now || function () {return + nova data};
I.vr = function (b) {se (I.global.execScript) I.global.execScript (b, "JavaScript"); senão if (I.global.eval) {if (null == I.ic) { try {I.global.eval ("var _evalTest_ = 1;")} catch (e) {} se ("indefinido"! = tipo de I.global._evalTest _) {try {delete I.global._evalTest_} catch (e ) {} I.ic =! 0} else I.ic =! 1} if (I.ic) I.global.eval (b); em alternativa {var c = I.global.document, d = c.createElement ( k); d.type = z; d.defer =! 1; d.appendChild (c.createTextNode (b)); c.head.appendChild (d); c.head.removeChild (d)}} else throw Erro ("goog.globalEval não disponível");};
I.ic = nulo; I.fr = funo (b, c) {funo d ​​(b) {b = b.split ("-"); para (var c = [], d = 0; d <b. comprimento; d ++) c.push (e (b [d])); retorno c.join ("-")} função e (b) {retorno I.kf [b] || b} if ("." = = String (b) .charAt (0)) Erro de lançamento ('className passado em goog.getCssName não deve iniciar com ".". Você passou:' + b); var f = lkf? "BY_WHOLE" == I .dj? e: d: B (); b = c? b + "-" + f (c): f (b); retorno I.global.Eh?I.global.Eh(b):b};I .qt = função (b, c) {I.kf = b; I.dj = c};
I.lr = função (b, c) {c && (b = b.replace (/ \ {\ $ ([^}] +)} / g, função (b, e) {retorno nulo! = C && e em c? c [e]: b})); retorno b}; I.mr = B (); I.qf = função (b, c) {I.ld (b, c, void 0)}; função (b, c, d) {b [c] = d}; I. $ a = função (b, c) {função d () {} d.prototype = c.prototype; b.Hc = c.prototype b.prototype = new d; b.prototype.constructor = b; bj = função (b, d, g) {para (var e = Array (arguments.length-2), f = 2; f <arguments .length; f ++) e [f-2] = argumentos [f]; retorno c.prototype [d] .apply (b, e)}};
I.Ji = função (b, c, d) {var e = argumentos.callee.caller; se (I.li || IZ &&! E) lançar erro ("arguments.caller não definido. Goog.base () não pode ser usado com código de modo estrito.Veja http://www.ecma-international.org/ecma-262/5.1/#sec-C");if("undefined"!==typeof e.Hc) {para (var f = Array (arguments.length-1), g = 1; g <argumentos.length; g ++) f [g-1] = argumentos [g]; return e.Hc.constructor.apply (b, f)} se ( typeof c! = y & "símbolo"! = typeof c) throw Error ("nomes de métodos fornecidos para goog.base deve ser uma string ou um símbolo"); f = Array (arguments.length-
2); para (g = 2; g <argumentos.length; g ++) f [g-2] = argumentos [g]; g =! 1; para (var h = b.construtor; h; h = h.Hc & h .Hc.constructor) if (h.prototype [c] === e) g =! 0; caso contrário, se (g) retornar h.prototype [c] .apply (b, f); if (b [c] = == e) return b.constructor.prototype [c] .apply (b, f); throw Erro ("goog.base chamado de um método de um nome para um método de um nome diferente");}; I.scope = function (b) {if (I.sg ()) erro de lançamento ("goog.scope não é suportado dentro de um módulo."); b.call (I.global)};
I.pa = function (b, c) {var d = c. Construtor, e = c.ol; d && d! = Object.prototype.constructor || (d = função () {throw Error ("não é possível instanciar uma interface ( nenhum construtor definido). ");}); d = I.pa. $ i (d, b); b && I. $ a (d, b); excluir c.construtor; excluir c.ol; I.pa.Ve (d.prototype, c); null! = e && (e instanceof Function? e (d): I.pa.Ve (d, e)); retorno d}; I.pa.gi = IZ;
I.pa. $ i = function (b, c) {função d () {var c = b.apply (isto, argumentos) || isto; c [I.Va] = c [I.Va]; construtor === d && e && Object.seal instanceof Function && Object.seal (c); return c} if (! I.pa.gi) retorno b; var e =! I.pa.mk (c); retorno d}; .mk = function (b) {retorno b &&prototype && b.prototype [I.pi]}; I.pa.Ge = ["construtor", t, "isPrototypeOf", x, A, "toString", "valueOf"] ;
I.pa.Ve = function (b, c) {para (var d em c) Object.prototype.hasOwnProperty.call (c, d) && (b [d] = c [d]); para (var e = 0; e <I.pa.Ge.length; e ++) d = I.pa.Ge [e], Object.prototype.hasOwnProperty.call (c, d) && (b [d] = c [d])} IXt = C (); I.pi = "goog_defineClass_legacy_unsealable"; I.debug = {}; I.debug.Error = função (b) {if (Error.captureStackTrace) Error.captureStackTrace (isto, I.debug (). Else {var c = Erro (). Stack; c && (this.stack = c)} b && (this.message = String (b))}; I. $ a (erro de I.debug.Error) ; I.debug.Error.prototype.name = "CustomError"; Ia = {}; Iafa = {Ja: 1, am: 2, ac: 3, pm: 4, Sm: 5, Rm: 6, mo: 7 , wm: 8, Sc: 9, Jm: 10, Mh: 11, Zn: 12}; Io = {}; Ioma = IZ; IoVb = função (b, c) {I.debug.Error.call (isto, Ioql (b, c))}; I. $ a (IoVb, I.debug.Error); IoVb.prototype.name = "AssertionError"; IoJh = função (b) {lance b;}; Iojd = IoJh; Ioql = função (b, c) {b = b.split ("% s"); para (var d = "", e = b.length-1, f = 0; f <e; f ++) d + = b [f] + (f <c.length? c [ f]: "% s"); retorno d + b [e]}; IoAa = função (b, c, d, e) {var f = "Asserção falhou"; if (d) {f + = ":" + d; var g = e} mais b && (f + = ":" + b, g = c); b = novo IoVb ("" + f, g || []); Iojd (b)}; Iout = função ( b) {Ioma && (Iojd = b)};
Ioassert = função (b, c, d) {Ioma &&! B && I.o.Aa ("", nulo, c, Array.prototype.slice.call (argumentos, 2)); retorno b}; Ioha = função (b, c) {Ioma && I.o.jd (novo IoVb ("Falha" + (b? ":" + b: ""), Array.prototype.slice.call (argumentos, 1)))}; IoHp = função (b , c, d) {Ioma &&! I.Rb (b) && I.o.Aa ("Número esperado, mas obtém% s:% s.", [I.ca (b), b], c, Array.prototype. slice.call (argumentos, 2)); return b};
IoKp = função (b, c, d) {Ioma &-! IM (b) && I.o.Aa ("Esperou cadeia mas obteve% s:% s.", [I.ca (b), b], c, Matriz .prototype.slice.call (arguments, 2)); return b}; Iotp = function (b, c, d) {Ioma &&! I.Ba (b) && I.o.Aa ("Função esperada, mas obteve% s: % s. ", [I.ca (b), b], c, Array.prototype.slice.call (argumentos, 2)); retorno b}; IoIp = função (b, c, d) {Ioma &&! I .ka (b) && I.o.Aa ("Objeto esperado, mas obteve% s:% s.", [I.ca (b), b], c, Array.prototype.slice.call (arguments, 2)) ; retorno b};
Iopp = function (b, c, d) {Ioma &&! I.isArray (b) && I.o.Aa ("Matriz esperada, mas obteve% s:% s.", [I.ca (b), b], c , Array.prototype.slice.call (arguments, 2)); return b}; Ioqp = function (b, c, d) {Ioma &&! I.Xj (b) && I.o.Aa ("Esperado booleano mas tem% s:% s. ", [I.ca (b), b], c, Array.prototype.slice.call (argumentos, 2)); retorno b}; Iorp = função (b, c, d) {! Ioma || I.ka (b) && b.nodeType == Iafa.Ja || IoAa ("Elemento Esperado, mas obteve% s:% s.", [I.ca (b), b], c, Array.prototype .slice.call (argumentos, 2)); return b};
Ipa = function (b, c, d, e) {! Ioma || b instanceof c || IoAa ("Instância esperada de% s mas obteve% s.", [Io $ f (c), Io $ f (b) ], d, Array.prototype.slice.call (argumentos, 3)); return b}; Iosp = function (b, c, d) {! Ioma || typeof b == u && isFinite (b) || IoAa (" % S esperado é um número finito, mas não é. ", [B], c, Array.prototype.slice.call (arguments, 2)); return b}; IoJp = function () {for (var b in Object.prototype) Ioha (b + "não deve ser enumerável em Object.prototype.")};
Io $ f = function (b) {retorno b instanceof Function? B.displayName || b.name || "nome do tipo desconhecido": b instanceof Object? B.constructor.displayName || b.constructor.name || Object. prototype.toString.call (b): null === b? "null": typeof b}; Ij = {}; I.Fa = I.Xc; IjCa =! 1; IjLk = funï¿½o (b) {retorno b [b.length-1]}; Ijos = IjLk; IjindexOf = I.Fa && (IjCa || Array.prototype.indexOf)? function (b, c, d) {retornar Array.prototype.indexOf.call (b, c , d)}: function (b, c, d) {d = null = = d? 0: 0> d? Math.max (0, b.length + d): d; se (IM (b)) retornar IM (c) && 1 == c.length? B.indexOf (c, d): - 1; para (; d <b.length; d ++) if (d em b && b [d] === c) retorno d; return-1};
IjlastIndexOf = I.Fa && (IjCa || Array.prototype.lastIndexOf)? Function (b, c, d) {retornar Array.prototype.lastIndexOf.call (b, c, null == d? B.length-1: d )}: function (b, c, d) {d = null = = d? b.length-1: d; 0> d && (d = Math.max (0, b.length + d)); (b)) retorna IM (c) && 1 == c.length? b.lastIndexOf (c, d): - 1; para (; 0 <= d; d -) se (d em b && b [d] == = c) retorno d; retorno-1};
IjforEach = I.Fa && (IjCa || Array.prototype.forEach)? Function (b, c, d) {Array.prototype.forEach.call (b, c, d)}: function (b, c, d) { para (var e = b.length, f = IM (b)? b.split (""): b, g = 0; g <e; g ++) g em f &&.c.call (d, f [g], g , bjjjf = função (b, c) {para (var d = IM (b) v b.split (""): b, e = b.length-1; 0 <= e; - e e em d & c.call (void 0, d [e], e, b)};
Ijfilter = I.Fa && (IjCa || Array.prototype.filter)? Função (b, c, d) {retornar Array.prototype.filter.call (b, c, d)}: função (b, c, d) {para (var e = b.length, f = [], g = 0, h = IM (b)? b.split (""): b, l = 0; l <e; l ++) se (l em h) {var m = h [l]; c.call (d, m, l, b) && (f [g ++] = m)} retorno f}; Ijmap = I.Fa && (IjCa || Array.prototype. map)? function (b, c, d) {retornar Array.prototype.map.call (b, c, d)}: function (b, c, d) {para (var e = b.length, f = Array (e), g = IM (b)? b.split (""): b, h = 0; h <e; h ++) h em g && (f [h] = c.call (d, g [h] , h, b)); retorno f};
Ijreduce = I.Fa && (IjCa || Array.prototype.reduce)? Function (b, c, d, e) {e && (c = I.bind (c, e)); retorno Array.prototype.reduce.call ( b, c, d)}: função (b, c, d, e) {var f = d; IjforEach (b, função (d, h) {f = c.call (e, f, d, h, b )}); return f}; IjreduceRight = I.Fa && (IjCa || Array.prototype.reduceRight)? function (b, c, d, e) {e && (c = I.bind (c, e)); Array.prototype.reduceRight.call (b, c, d)}: função (b, c, d, e) {var f = d; Ijxf (b, função (d, h) {f = c.call (e , f, d, h, b)}); retorno f};
Ijsome = I.Fa && (IjCa || Array.prototype.some)? Função (b, c, d) {retornar Array.prototype.some.call (b, c, d)}: função (b, c, d) {para (var e = b.length, f = IM (b)? b.split (""): b, g = 0; g <e; g ++) if (g em f &&.c.call (d, f [g ], g, b)) return! 0; return! 1}; Ijevery = I.Fa && (IjCa || Array.prototype.every)? function (b, c, d) {retornar Array.prototype.every.call ( b, c, d)}: funç˜ao (b, c, d) {para (var e = comprimento, f = IM (b) b b.split (""): b, g = 0; g <e ; g ++) if (g em f &&! c.call (d, f [g], g, b)) retorno! 1; retorno! 0};
Ijcount = function (b, c, d) {var e = 0; IjforEach (b, funo (b, g, h) {c.call (d, b, g, h) & &; ++ e}, d); return e}; Ijfind = function (b, c, d) {c = IjfindIndex (b, c, d); retorno 0> c? null: IM (b)? b.charAt (c): b [c]} IjfindIndex = funç˜ao (b, c, d) {para (var e = comprimento, f = IM (b)? B.split (""): b, g = 0; g <e; g ++) if ( g em f && c.call (d, f [g], g, b)) retorno g; retorno-1}; IjKq = função (b, c, d) {c = Ijsj (b, c, d); retorno 0 > c? null: IM (b)? b.carAt (c): b [c]};
Ijsj = função (b, c, d) {para (var e = IM (b)? B.split (""): b, f = b.length-1; 0 <= f; f -) if ( f in e && c.call (d, e [f], f, b)) retorno f; retorno-1}; Ijcontains = função (b, c) {retorno 0 <= IjíndiceOf (b, c)}; IjQb = função (b) {return 0 == b.length}; Ijclear = function (b) {if (! I.isArray (b)) para (var c = b.length-1; 0 <= c; c--) delete b [c]; b.length = 0}; IjDr = função (b, c) {Ijcontains (b, c) || ​​b.push (c)}; Ijgg = função (b, c, d) {Ijsplice (b, d, 0, c)}; IjFr = funo (b, c, d) {I.eb (Ijsplice, b, d, 0) .apply (null, c)};
IjinsertBefore = function (b, c, d) {var e; 2 == argumentos.length || 0> (e = IjindexOf (b, d))? B.push (c): Ijgg (b, c, e) }; Ijremove = function (b, c) {c = IjindexOf (b, c); var d; (d = 0 <= c) && I.j.wb (b, c); retorno d}; IjYs = funo ( b, c) {c = IjlastIndexOf (b, c); retorno 0 <= c? (Ijwb (b, c),! 0) :! 1}; Ijwb = funç˜ao (b, c) {return 1 == Matriz .prototype.splice.call (b, c, 1) .comprimento}; IjXs = funç˜ao (b, c, d) {c = IjfindIndex (b, c, d); retorno 0 <= c ((Ijwb (b, c), 0) :! 1};
IjUs = função (b, c, d) {var e = 0; Ijxf (b, função (f, g) {c.call (d, f, g, b) & ij.wb (b, g) && e ++ }); return e}; Ijconcat = function (b) {retornar Array.prototype.concat.apply ([], argumentos)}; Ijjoin = function (b) {retornar Array.prototype.concat.apply ([], argumentos )}; Ijih = function (b) {var = b.length; if (0 <c) {para (var d = Matriz (c), e = 0; e <c; e ++) d [e] = b [e]; return d} return []}; Ijclone = Ijih;
Ijextend = function (b, c) {para (var d = 1; d <argumentos.length; d ++) {var e = argumentos [d]; se (I.Nb (e)) {var f = b.length | | 0, g = e.length || 0; b.length = f + g; para (var h = 0; h <g; h ++) b [f + h] = e [h]} mais b.push ( e)}}; Ijsplice = function (b, c, d, e) {retornar Array.prototype.splice.apply (b, Ijslice (argumentos, 1))}; Ijslice = function (b, c, d) {return 2> = arguments.length? Array.prototype.slice.call (b, c): Array.prototype.slice.call (b, c, d)};
IjVs = função (b, c, d) {função e (b) {retorno I.ka (b)? "O" + I.ag (b): (tipo de b) .charAt (0) + b} c = c || b; d = d || e; para (var f = {}, g = 0, h = 0; h <comprimento_leve;) {var l = b [h ++], m = d (l) Object.prototype.hasOwnProperty.call (f, m) || (f [m] =! 0, c [g ++] = l)} c.length = g}; IjYe = funç˜ao (b, c, d) { return IjZe (b, d || IjOa,! 1, c)}; IjOp = função (b, c, d) {retorno IjZe (b, c, 0, void 0, d)}; IjZe = função (b c, d, e, f) {para (var g = 0, h = b.length, l; g <h;) {var m = g + h >> 1; var r = d? c.call ( f, b [m], m, b): c (e, b [m]); 0 <r? g = m + 1: (h = m, l =! r)} retorno l? g: ~ g };
Ijsort = função (b, c) {b.sort (c || IjOa)}; IjRt = função (b, c) {para (var d = Matriz (comprimento_b), e = 0; e <b.length ; e ++) d [e] = {índice: e, valor: b [e]}; var f = c || IjOa; Ijsort (d, função (b, c) {retorno f (b.valor, c.value ) || b.index-c.index}); para (e = 0; e <b.length; e ++) b [e] = d [e] .value}; Ijml = função (b, c, d) {var e = d || IjOa; Ijsort (b, função (b, d) {return e (c (b), c (d))})}; IjOt = função (b, c, d) {Ijml ( b, função (b) {retorno b [c]}, d)};
Ijjs = função (b, c, d) {c = c || IjOa; para (var e = 1; e <b.length; e ++) {var f = c (b [e-1], b [e] ); if (0 <f || 0 == f && d) return! 1} return! 0}; IjIb = function (b, c) {se (! I.Nb (b) ||! I.Nb (c) || b.length! = c.length) return! 1; para (var d = b.length, e = Ijfj, f = 0; f <d; f ++) if (! e (b [f], c [ f])) return! 1; return! 0}; Ijcq = function (b, c, d) {d = d || IjOa; para (var e = Math.min (comprimento_b, c.length), f = 0; f <e; f ++) {var g = d (b [f], c [f]); se (0! = G) retornará g} retorne IjOa (comprimento_b.c.length)}; IjOa = funo (b, c) {retorno b> c? 1: b <c? -1: 0};
IjHr = função (b, c) {retorno-IjOa (b, c)}; Ijfj = função (b, c) {retorno b === c}; IjMp = função (b, c, d) {d = IjYe (b, c, d); retorno 0> d? (Ijgg (b, c, - (d + 1)),! 0) :! 1}; IjNp = funç˜ao (b, c, d) {c = IjYe (b, c, d); return 0 <= c Ijwb (b, c):! 1}; IjQp = funç˜ao (b, c, d) {para (var e = {}, f = 0; f < b.length; f ++) {var g = b [f], h = c.call (d, g, f, b); IW (h) && (e [h] || (e [h] = [] empurrar (g)} retornar e}; Ijau = function (b, c, d) {var e = {}; IjforEach (b, funç˜ao (f, g) {e [c.call (d, f, g, b)] = f}); return e};
IjQs = função (b, c, d) {var e = [], f = 0, g = b; d = d || 1; void 0! == c && (f = b, g = c); 0> d * (gf)) return []; se (0 <d) para (b = f; b <g; b + = d) e.push (b); outro para (b = f; b> g; b + = d) e.push (b); return e}; Ijrepeat = função (b, c) {para (var d = [], e = 0; e <c; e ++) d [e] = b; d); Ijflatten = function (b) {para (var c = [], d = 0; d <argumentos.length; d ++) {var e = argumentos [d]; if (I.isArray (e)) para ( var f = 0; f <e.length; f + = 8192) para (var g = Ijflatten.apply (nulo, Ijslice (e, f, f + 8192)), h = 0; h <g.length; h ++) c.push (g [h]); senão c.push (e)} retorna c};
Ijrotate = função (b, c) {b.length && (c% = comprimento_B, 0 <c? Array.prototype.unshift.apply (b, b.splice (-c, c)): 0> c && Array.prototype .push.apply (b, b.splice (0, -c))); retorno b}; IjAs = função (b, c, d) {c = Array.prototype.splice.call (b, c, 1) ; Array.prototype.splice.call (b, d, 0, c [0])};
Ijqu = function (b) {if (! Argumentos.length) return []; para argumentos (var c = [], d = argumentos [0] .length, e = 1; e <argumentos.length; e ++) [e ] .length <d && (d = argumentos [e] .comprimento); para (e = 0; e <d; e ++) {para (var f = [], g = 0; g <argumentos.length; g ++) f .push (argumentos [g] [e]); c.push (f)} retorno c}; IjNt = função (b, c) {c = c || Math.random; para (var d = b.length- 1; 0 <d; d -) {var = Math.floor (c () * (d + 1)), f = b [d]; b [d] = b [e]; b [e] = f}}; Ijiq = funç˜ao (b, c) {var d = []; Ij forEach (c, funç˜ao (c) {d.push (b [c])}); return d};
Ijfq = função (b, c, d) {retornar Ijconcat.apply ([], Ijmap (b, c, d))}; I.async = {}; I.async.Xb = função (b, c, d ) {this.sk = d; this.cj = b; this.Pk = c; this.vc = 0; this.qc = null}; I.async.Xb.prototype.get = function () {if (0 <this.vc) {this.vc -; var b = this.qc; this.qc = b.next; b.next = null} mais b = this.cj (); retorno b}; I.async. Xb.prototype.put = function (b) {this.Pk (b); this.vc <this.sk&& (this.vc ++, b.next = this.qc, this.qc = b)}; I.debug. aa = {}; I.debug.Tm = C (); I.debug.aa.vb = []; I.debug.aa.Pd = []; I.debug.aa.Lg =! 1; debug.aa.register = função (b) {I.debug.aa.vb [I.debug.aa.vb.length] = b; se (I.debug.aa.Lg) para (var c = I.debug .aa.Pd, d = 0; d <c.length; d ++) b (I.bind (c [d] .Ml, c [d]))}; I.debug.aa.zs = function (b) {I.debug.aa.Lg =! 0; para (var c = I.bind (b.Ml, b), d = 0; d <I.debug.aa.vb.length; d ++) I.debug. aa.vb [d] (c); I.debug.aa.Pd.push (b)}; I.debug.aa.ju = funç˜ao (b) {var c = I.debug.aa.Pd; b = I.bind (bs, b);para (var d = 0; d <I.debug.aa.vb.length; d ++) I.debug.aa.vb [d] (b); c.length -}; Iaon = C (); Iac = função (b) {this.rl = b}; Iacprototype.toString = D ("rl"); IacNl = new Iac ("A"); IacOl = new Iac ("ABBR"); IacQl = new Iac ("ACRONYM "); IacRl = new Iac (" ENDEREÇO ​​"); IacVl = new Iac (" APPLET "); IacWl = new Iac (" AREA "); IacXl = new Iac (" ARTICLE "); IacYl = new Iac (" ASIDE "); Iacbm = new Iac (" AUDIO "); Iaccm = new Iac (" B "); Iacdm = new Iac (" BASE "); Iacem = new Iac (" BASEFONT "); Iacfm = new Iac (" BDI "); Iacgm = new Iac (" BDO "); Iacjm = new Iac (" BIG "); Iackm = new Iac (" BLOCKQUOTE ");c = função (b) {this.rl = b}; Iacprototype.toString = D ("rl"); IacNl = new Iac ("A"); IacOl = new Iac ("ABBR"); IacQl = new Iac ( "ACRONYM"); IacRl = new Iac ("ENDEREÇO"); IacVl = new Iac ("APPLET"); IacWl = new Iac ("AREA"); IacXl = new Iac ("ARTIGO"); IacYl = new Iac ( "ASIDE"); Iacbm = new Iac ("AUDIO"); Iaccm = new Iac ("B"); Iacdm = new Iac ("BASE"); Iacem = new Iac ("BASEFONT"); Iacfm = new Iac ( "BDI"); Iacgm = new Iac ("BDO"); Iacjm = new Iac ("BIG"); Iackm = new Iac ("BLOCKQUOTE");c = função (b) {this.rl = b}; Iacprototype.toString = D ("rl"); IacNl = new Iac ("A"); IacOl = new Iac ("ABBR"); IacQl = new Iac ( "ACRONYM"); IacRl = new Iac ("ENDEREÇO"); IacVl = new Iac ("APPLET"); IacWl = new Iac ("AREA"); IacXl = new Iac ("ARTIGO"); IacYl = new Iac ( "ASIDE"); Iacbm = new Iac ("AUDIO"); Iaccm = new Iac ("B"); Iacdm = new Iac ("BASE"); Iacem = new Iac ("BASEFONT"); Iacfm = new Iac ( "BDI"); Iacgm = new Iac ("BDO"); Iacjm = new Iac ("BIG"); Iackm = new Iac ("BLOCKQUOTE");ENDEREÇO ​​"); IacVl = new Iac (" APPLET "); IacWl = new Iac (" AREA "); IacXl = new Iac (" ARTIGO "); IacYl = new Iac (" ASIDE "); Iacbm = new Iac (" AUDIO "); Iaccm = new Iac (" B "); Iacdm = new Iac (" BASE "); Iacem = new Iac (" BASEFONT "); Iacfm = new Iac (" BDI "); Iacgm = new Iac (" BDO "); Iacjm = new Iac (" BIG "); Iackm = new Iac (" BLOCKQUOTE ");ENDEREÇO ​​"); IacVl = new Iac (" APPLET "); IacWl = new Iac (" AREA "); IacXl = new Iac (" ARTIGO "); IacYl = new Iac (" ASIDE "); Iacbm = new Iac (" AUDIO "); Iaccm = new Iac (" B "); Iacdm = new Iac (" BASE "); Iacem = new Iac (" BASEFONT "); Iacfm = new Iac (" BDI "); Iacgm = new Iac (" BDO "); Iacjm = new Iac (" BIG "); Iackm = new Iac (" BLOCKQUOTE ");Iacm = new Iac ("BIG"); Iackm = new Iac ("BLOCKQUOTE");Iacm = new Iac ("BIG"); Iackm = new Iac ("BLOCKQUOTE");
Iaclm = new Iac ("BODY"); Iacqe = new Iac ("BR"); Iacmm = new Iac ("BOTÃO"); Iacnm = new Iac ("CANVAS"); Iacom = new Iac ("CAPTION"); Iacqm = new Iac ("CENTER"); Iacrm = new Iac ("CITE"); Iacsm = new Iac ("CODE"); Iactm = new Iac ("COL"); Iacum = new Iac ("COLGROUP"); Iacvm = new Iac ("COMMAND"); Iacxm = new Iac ("DATA"); Iacym = new Iac ("DATALIST"); Iaczm = new Iac ("DD"); IacAm = new Iac ("DEL"); IacCm = new Iac ("DETALHES"); IacDm = new Iac ("DFN"); IacEm = new Iac ("DIALOG");
IacFm = new Iac ("DIR"); IacGm = new Iac ("DIV"); IacHm = new Iac ("DL"); IacKm = new Iac ("DT"); IacNm = new Iac ("EM"); IacOm = new Iac ("EMBED"); IacVm = new Iac ("FIELDSET"); IacWm = new Iac ("FIGCAPTION"); IacXm = new Iac ("FIGURA"); IacYm = new Iac ("FONT"); IacZm = new Iac ("FOOTER"); Iac $ m = new Iac ("FORM"); Iacan = new Iac ("FRAME"); Iacbn = new Iac ("FRAMESET"); Iaccn = new Iac ("H1") Iacdn = novo Iac ("H2"); Iacen = novo Iac ("H3"); Iacfn = novo Iac ("H4"); Iacgn = novo Iac ("H5");
Iachn = new Iac ("H6"); Iacjn = new Iac ("HEAD"); Iackn = new Iac ("HEADER"); Iacn = new Iac ("HGROUP"); Iacnn = new Iac ("HR"); Iacnn = new Iac ("HTML"); Iacpn = new Iac ("I"); Iacsn = new Iac ("IFRAME"); Iactn = new Iac ("IMG"); Iacun = new Iac ("INPUT"); Iacv = new Iac ("INS"); IacAn = new Iac ("ISINDEX"); IacDn = new Iac ("KBD"); IacEn = new Iac ("KEYGEN"); IacFn = new Iac ("LABEL"); IacHn = new Iac ("LEGEND"); IacIn = new Iac ("LI"); IacJn = new Iac ("LINK"); IacNn = new Iac ("MAIN");
IacOn = new Iac ("MAP"); IacPn = new Iac ("MARK"); IacQn = new Iac ("MATH"); IacRn = new Iac ("MENU"); IacSn = new Iac ("MENUITEM"); IacTn = new Iac ("META"); IacUn = new Iac ("METER"); IacWn = new Iac ("NAV"); IacXn = new Iac ("NOFRAMES"); IacYn = new Iac ("NOSCRIPT"); Iacao = new Iac ("OBJETO"); Iacbo = new Iac ("OL"); Iacco = new Iac ("OPTGROUP"); Iaceo = new Iac ("OPTION"); Iacfo = new Iac ("OUTPUT"); Iacô = novo Iac ("P"); Iácio = novo Iac ("PARAM"); Iacjo = novo Iac ("IMAGEM");
Iaclo = novo Iac ("PRE"); Icno = novo Iac ("PROGRESSO"); IacQ = novo Iac ("Q"); Iacoo = novo Iac ("RP"); Iacpo = novo Iac ("RT"); Iacqo = novo Iac ("RTC"); Iacro = novo Iac ("RUBY"); Iacto = novo Iac ("S"); Iacwo = novo Iac ("SAMP"); Iacxo = novo Iac (k); Iacyo = new Iac ("SECTION"); Iaczo = new Iac ("SELECT"); IacAo = new Iac ("SMALL"); IacBo = new Iac ("SOURCE"); IacCo = new Iac ("SPAN"); IacDo = new Iac ("STRIKE"); IacEo = new Iac ("STRONG"); IacFo = new Iac ("STYLE"); IacGo = new Iac ("SUB");
IacHo = new Iac ("SUMMARY"); IacIo = new Iac ("SUP"); IacJo = new Iac ("SVG"); IacKo = new Iac ("TABLE"); IacLo = new Iac ("TBODY"); IacMo = novo Iac ("TD"); IacNo = novo Iac ("MODELO"); IacOo = novo Iac ("TEXTAREA"); IacPo = novo Iac ("TFOOT"); IacQo = novo Iac ("TH"); IacRo = new Iac ("THEAD"); IacSo = new Iac ("TIME"); IacTo = new Iac ("TITLE"); IacU = new Iac ("TR"); IacVo = new Iac ("TRACK"); IacZo = new Iac ("TT"); Iacap = new Iac ("U"); Iacpp = new Iac ("UL"); Iaccp = new Iac ("VAR");
Iacep = new Iac ("VIDEO"); Iacfp = new Iac ("WBR"); IL = {}; ILWi = funo (b) {funo de retorno () {retorno b}}; ILUm = E (! 1); ILYo = E (! 0); IL $ n = E (nulo); ILVj = B (); ILerror = função (b) {função de retorno () {erro de lançamento (b);}}; ILha = função (b) {return function () {lançar b;}}; ILlock = function (b, c) {c = c || 0; função return () {return b.apply (isto, Array.prototype.slice.call (argumentos, 0, c))}}; ILHs = function (b) {função de retorno () {argumentos de retorno [b]}};
ILMs = função (b, c) {var d = Array.prototype.slice.call (argumentos, 1); função de retorno () {var = Array.prototype.slice.call (argumentos); c.push.apply ( c, d); retorno b.apply (isto, c)}}; ILpu = função (b, c) {retorno ILfl (b, ILWi (c))}; ILGq = função (b, c) {função de retorno ( d) {retorno c? b == d: b === d}}; ILeq = função (b, c) {var d = argumentos, e = d.length; função de retorno () {var b; e & (b = d [e-1] .apply (isto, argumentos)); para (var c = e-2; 0 <= c; c -) b = d [c] .call (isto, b); retorno b }};
ILfl = função (b) {var c = argumentos, d = c.length; função de retorno () {para (var b, f = 0; f <d; f ++) b = c [f] .apply (isto, argumentos ); retorno b}}; ILand = função (b) {var = argumentos, d = c.length; função de retorno () {para (var b = 0; b <d; b ++) if (! c [b] .apply (this, arguments)) return! 1; return! 0}}; ILor = function (b) {var = = argumentos, d = c.length; função de retorno () {para (var b = 0; b < d; b ++) if (c [b] .apply (isto, argumentos)) return! 0; return! 1}}; ILGs = função (b) {return function () {return! b.apply (isto, argumentos) }};
ILcreate = function (b, c) {função d () {} d.prototype = b.prototype; var e = novo d; b.apply (e, Array.prototype.slice.call (argumentos, 1)); e}; ILAh =! 0; ILQi = função (b) {var c =! 1, d; função de retorno () {if (! ILAh) return b (); c || (d = b (), c = ! 0); return d}}; ILonce = function (b) {var c = b; função return () {if (c) {var b = c; c = nulo; b ()}}}; ILuq = função (b, c, d) {var e = 0; função de retorno (f) {I.global.clearTimeout (e); var g = argumentos; e = I.global.setTimeout (function () {b.apply (d g)}, c)}};
ILYt = função (b, c, d) {função e () {g = I.global.setTimeout (f, c); b.apply (d, l)} função f () {g = 0; h && (h =! 1, e ()}} var g = 0, h =! 1, l = []; função de retorno (b) {l = argumentos; g? H =! 0: e ()}}; ILRs = função (b, c, d) {função e () {f = 0} var f = 0; função de retorno (g) {f || (f = I.global.setTimeout (e, c), b.apply (d , argumentos))}}; Se = {}; IfRc =! 1; IfOh =! 1; IfQe = {Ee: "\ u00a0"}; IfstartsWith = function (b, c) {retorno 0 == b.lastIndexOf ( c, 0)}; IfendsWith = function (b, c) {var d = b.length-c.length; retorno 0 <= d && b.indexOf (c, d) == d}; Ifbd = função (b, c ) {return 0 == Se $ e (c, b.substr (0, c.length))}; IfVp = função (b, c) {return 0 == Se $ e (c, b.substr (b. length-c.length, c.length)); IfWp = função (b, c) {retorno b.toLowerCase () == c.toLowerCase ()};
IfWt = função (b, c) {para (var d = b.split ("% s"), e = "", f = Array.prototype.slice.call (argumentos, 1); f.length && 1 <d. comprimento;) e + = d.shift () + f.shift (); retorno e + d.join ("% s")}; Ifbq = função (b) {retorno b.replace (/ [\ s \ xa0] + / g, "") .replace (/ ^ \ s + | \ s + $ / g, "")}; IfGd = função (b) {return / ^ [\ s \ xa0] * $ /. teste (b) }; IfRr = function (b) {return 0 == b.length}; IfQb = IfGd; IfZj = function (b) {retorno IfGd (IfDk (b))}; IfQr = IfZj; IfLr = function (b) { return! / [^ \ t \ n \ r] /. teste (b)}; IfIr = function (b) {retorno! / [^ a-zA-Z] /. teste (b)};
Ifds = função (b) {retorno! / [^ 0-9] /. Teste (b)}; IfJr = função (b) {retorno! / [^ A-zA-Z0-9] /. Teste (b) Ifks = function (b) {return "" == b}; Ifls = função (b) {return 1 == b.length && "" <= b && "~"> = b || "\ u0080" <= b && "\ ufffd"> = b}; IfUt = função (b) {retorno b.replace (/ (\ r \ n | \ r | \ n) + / g, "")}; IfTi = função (b) {return b.replace (/ (\ r \ n | \ r | \ n) / g, "\ n")}; IfFs = função (b) {retornar b.replace (/ \ xa0 | \ s / g, "")}; IfEs = function (b) {retornar b.replace (/ \ xa0 | [\ t] + / g, "")};
Ifaq = function (b) {retornar b.replace (/ [\ t \ r \ n] + / g, "") .replace (/ ^ [\ t \ r \ n] + | [\ t \ r \ n ] + $ / g, "")}; Iftrim = I.Xc && String.prototype.trim? function (b) {retorno b.trim ()}: function (b) {retorno / ^ [\ s \ xa0] * ( [\ s \ S] *?) [\ s \ xa0] * $ /. exec (b) [1]}; IftrimLeft = função (b) {retorno b.replace (/ ^ [\ s \ xa0] + / IftrimRight = function (b) {return b.replace (/ [\ s \ xa0] + $ /, "")}; Se $ e = function (b, c) {b = String (b ) .toLowerCase (); c = String (c) .toLowerCase (); retorno b <c? -1: b == c? 0: 1};
IfNg = função (b, c, d) {se (b == c) retorna 0; se (! B) retorna-1; se (! C) retorna 1; para (var e = b.toLowerCase (). (d), f = c.toLowerCase (), match (d), g = Math.min (e.length, f.length), h = 0; h <g; h ++) {d = e [h]; var l = f [h]; se (d! = l) retornar b = parseInt (d, 10) ,! éNaN (b) && (c = parseInt (l, 10) ,! éNaN (c) && b-c) ? bc: d <l? -1: 1} retorno e.length! = f.length? e.length-f.length: b <c? -1: 1}; IfGr = function (b, c) {retorno IfNg (b, c, / \ d + | \ D + / g)}; Ifuj = função (b, c) {return IfNg (b, c, / \ d + | \. \ D + | \ D + / g)}; = Ifuj; Iflu = function (b) {retorna encodeURIComponent (String (b))};
Ifku = function (b) {retornar decodeURIComponent (b.replace (/ \ + / g, ""))}; IfMg = função (b, c) {retornar b.replace (/ (\ r \ n | \ r | \ n) / g, c? "<br />": "<br>")};
Ifva = função (b, c) {se (c) b = b.replace (Ifee, "& amp;"). Substitua (IfDe, "& lt;"). Substitua (IfAe, "& gt;"). Substitua (IfKe , "& quot;"). replace (IfMe, "& # 39;"). replace (IfFe, "& # 0;"), IfRc && (b = b.replace (Ifwe, "& # 101;")); else {if (! Ifsh.test (b)) retorna b; -1! = b.indexOf ("&") && (b = b.replace (Ifee, "& amp;")) - 1! = b. indexOf ("<") && (b = b.replace (IfDe, "& lt;")); - 1! = b.indexOf (">") && (b = b.replace (IfAe, "& gt;") ); - 1! = B.indexOf ('"') && (b = b.replace (IfKe," & quot; ")); - 1! = B.indexOf (" '") && (b = b.replace (IfMe, "& # 39;")); - 1! = B.indexOf ("\ x00") &&
(b = b.replace (IfFe, "& # 0;")); IfRc && - 1! = b.indexOf ("e") && (b = b.replace (Ifwe, "& # 101;"))} return b}; Ifee = / & / g; IfDe = / </ g; IfAe = /> / g; IfKe = / "/ g; IfMe = / '/ g; IfFe = / \ x00 / g; Ifwe = / e / g; Ifsh = IfRc? / [\ x00 & <> "'e] /: / [\ x00 & <>"'] /; Ifkh = função (b) {return If contém (b, "&") ?! IfOh && "document" em I.global? Iflh (b): Ifzl(b):b};Ifhu=function(b,c){return If contém (b, "&")? Iflh (b, c): b};
Iflh = função (b, c) {var d = {"& amp;": "&", "& lt;": "<", "& gt;": ">", "& quot;": '"'}; var e = c? c.createElement ("div"): I.global.document.createElement ("div"); return b.replace (IfSh, funo (b, c) {var = d [b]; se (f) return f; "#" == c.charAt (0) && (c = Número ("0" + c.substr (1)), isNaN (c) || ​​(f = String.fromCharCode (c) )); f || (e.innerHTML = b + "", f = e.firstChild.nodeValue.slice (0, -1)); retorno d [b] = f})};
Ifzl = função (b) {return b.replace (/ & ([^;] +); / g, função (b, d) {switch (d) {caso "amp": retorno "&"; caso "lt ": return" <"; caso" gt ": return"> "; caso" quot ": return '"'; padrão: retorno "#"! = d.charAt (0) || (d = Number ("0 "+ d.substr (1)), éNaN (d))? b: String.fromCharCode (d)}})}; IfSh = / & ([^; \ s <&] +);? / g; IfJl = function (b) {retornar IfMg (b.replace (/ / g, "& # 160;"), void 0)}; IfNs = function (b) {retornar b.replace (/ (^ | [\ n] ) /g,"$1"+IfQe.Ee)};
IfVt = function (b, c) {para (var d = c.length, e = 0; e <d; e ++) {var f = 1 = = dc: c.charAt (e); if (b. charAt (0) == f && b.charAt (b.length-1) == f) return b.substring (1, b.length-1)} retorno b}; Iftruncate = função (b, c, d) {d && (b = Ifkh (b)); b.length> c && (b = b.substring (0, c-3) + "..."); d && (b = Ifva (b)); retorno b}; = função (b, c, d, e) {d && (b = Ifkh (b)); e && b.length> c? (e> c && (e = c), b = b.substring (0, ce) + " ... "+ b.substring (b.length-e)): b.length> c && (e = Math.floor (c / 2), b = b.substring (0, e + c% 2) +" ... "+ b.substring (b.length-e)); d && (b = Ifva (b)); retorno b};
IfYd = {"\ x00": "\\ 0", "\ b": "\\ b", "\ f": "\\ f", "\ n": "\\ n", "\ r ":" \\ r "," \ t ":" \\ t "," \ x0B ":" \\ x0B ", '"': '\\ "'," \\ ":" \\\\ "," <":" <"}; Ifsc = {" '":" \\' "}; Ifquote = function (b) {b = String (b); para (var c = ['"'], d = 0; d <b.length; d ++) {var e = b.charAt (d), f = e.charCodeAt (0); c [d + 1] = IfYd [e] || (31 <f && 127> f e: Ifnf (e))} c.push ('"'; return c.join (" ")}; IfHq = função (b) {para (var c = [], d = 0; d < b.length; d ++) c [d] = Ifnf (b.charAt (d)); retorno c.join ("")};
Ifnf = function (b) {if (b em Ifsc) retorna Ifsc [b]; if (b em IfYd) retorna Ifsc [b] = IfYd [b]; var c = b.charCodeAt (0); se (31 < c && 127> c) var d = b; senão {if (256> c) {se (d = "\\ x", 16> c || 256 <c) d + = "0"} mais d = "\\ u ", 4096> c && (d + =" 0 "); d + = c.toString (16) .toUpperCase ()} return Ifsc [b] = d}; If contém = função (b, c) {return-1! = B .indexOf (c)}; Ifaf = function (b, c) {return Se contém (b.toLowerCase (), c.toLowerCase ())}; Ifjq = função (b, c) {retorno b && c? b.split (c ) .length-1: 0}; Ifwb = B ();
Ifremove = function (b, c) {return b.replace (c, "")}; IfTs = função (b, c) {c = novo RegExp (IfQd (c), "g"); retorno b.replace ( c, "")}; IfZs = function (b, c, d) {c = new RegExp (IfQd (c), "g"); retorno b.replace (c, d.replace (/ \ $ / g, "$$$$"))}; IfQd = function (b) {return Cadeia (b) .replace (/([-()\[\]{}+?*.$\^ |,: # <! \\]) / g, "\\ $ 1"). replace (/ \ x08 / g, "\\ x08")}; Ifrepeat = String.prototype.repeat? function (b, c) {retorno b.repeat ( c)}: function (b, c) {return Matriz (c + 1) .join (b)};
IfLs = função (b, c, d) {b = IW (d)? B.aFixed (d): Cadeia (b); d = b.indexOf ("."); - 1 == d && (d = b .length); return Ifrepeat ("0", Math.max (0, cd)) + b}; IfDk = função (b) {return null == b? "": String (b)}; IfRp = função ( b) {return Array.prototype.join.call (argumentos, "")}; Ifrr = function () {retornar Math.floor (2147483648 * Math.random ()). toString (36) + Math.abs (Math. floor (2147483648 * Math.random ()) ^ I.now ()). toString (36)};
IfDb = função (b, c) {var d = 0; b = Iftrim (Seqüência (b)). Split ("."); C = Iftrim (Seqüência (c)). Split ("."); var e = Math.max (b.length, c.length), f = 0; 0 = = d && f <e; f ++) {var g = b [f] || "", h = c [f] || ";; faça {g = / (\ d *) (\ D *) (. *) /. exec (g) || [" "," "," "," "]; h = / (\ d *) (\ D *) (. *) /. Exec (h) || ["", "", "", ""]; se (0 == g [0] .comprimento && 0 == h [0] quebra de comprimento; d = Ifcd (0 = g [1] .comprimento? 0: parseInt (g [1], 10), 0 = h [1] .comprimento? 0: parseInt (h [1], 10)) || Ifcd (0 == g [2] .comprimento, 0 == h [2] .comprimento) || Ifcd (g [2], h [2]); g = g [3]; h = h [3]} enquanto (0 == d)} retorna d};
Ifcd = função (b, c) {retorno b <c? -1: b> c? 1: 0}; IfAr = função (b) {para (var c = 0, d = 0; d <b.length; ++ d) c = 31 * c + b.charCodeAt (d) >>> 0; retorno c}; IfAl = 2147483648 * Math.random () | 0; Ifsq = função () {retorno "goog _" + IfAl ++} Se $ t = function (b) {var c = Number (b); return 0 == c && I.f.Gd (b)? NaN: c}; IfWr = function (b) {retorno / ^ [az] + ([AZ] [az] *) * $ /. Teste (b)}; Ifms = função (b) {retorno / ^ ([AZ] [az] *) + $ / teste (b)}; function (b) {return Cadeia (b) .replace (/ \ - ([az]) / g, função (b, d) {retorno d.toUpperCase ()})};
Ifbu = function (b) {return Cadeia (b) .replace (/ ([AZ]) / g, "- $ 1"). ToLowerCase ()}; Ifcu = função (b, c) {c = IM (c) ? IfQd (c): "\\ s"; retorno b.replace (new RegExp ("(^" + (c? "| [" + C + "] +": "") + ") ([az]) "," g "), função (b, c, f) {retorno c + f.toUpperCase ()})}; IfUp = função (b) {return String (b.charAt (0)). toUpperCase () + String (b.substr (1)). ToLowerCase ()}; IfparseInt = função (b) {isFinite (b) && (b = String (b)); retorna IM (b)? / ^ \ S * -? 0x /i.test(b)?parseInt(b.16):parseInt(bolic ):NaN};
IfPt = função (b, c, d) {b = b.split (c), para (var e = []; 0 <d && b.length;) e.push (b.shift ()), d--; b.length && e.push (b.join (c)); return e}; Ifps = função (b, c) {if (c) tipo de c == y && (c = [c]); senão retorna b; var d = -1, e = 0; e <c.length; e ++) se (""! = c [e]) {var = b.lastIndexOf (c [e]); f> d && (d = f )} return-1 == d? b: b.slice (d + 1)};
IfBq = função (b, c) {var d = [], e = []; se (b == c) retorna 0; se (! B.length ||! C.length) retorna Math.max (b. comprimento, c.length), para (var f = 0; f <c.length + 1; f ++) d [f] = f; para (f = 0; f <b.length; f ++) {e [0] = f + 1; para (var g = 0; g <c.length; g ++) e [g + 1] = Math.min (e [g] + 1, d [g + 1] + 1, d [g ] + Number (b [f]! = C [g])), para (g = 0; g <d.length; g ++) d [g] = e [g]} return e [c.length]}; Ig = {}; IguserAgent = {}; IguserAgent.A = {}; IguserAgent.A.Nf = function () {var b = IguserAgent.A.Ej (); retorno b && (b = b.userAgent)? B: "" ;; IguserAgent.A.Ej = function () {return I.global.navigator}; IguserAgent.A.mh = IguserAgent.A.Nf (); IguserAgent.A.Kt = função (b) {IguserAgent.A .mh = b || IguserAgent.A.Nf ()}; IguserAgent.A.pb = função () {return IguserAgent.A.mh}; IguserAgent.AK = função (b) {return Ifcontains (IguserAgent.A.pb (), b)};
IguserAgent.A.Ig = function (b) {retorno Ifaf (IguserAgent.A.pb (), b)}; IguserAgent.A.rf = função (b) {para (var c = / (\ w [\ w] +) \ / ([^ \ s] +) \ s * (?: \ ((. *?) \))? / g, d = [], e; e = c.exec (b);) d .push ([e [1], e [2], e [3] || void 0]); return d}; I.objecto = {}; I.object.is = function (b, c) {return b === c? 0! == b || 1 / b === 1 / c: b! == b && c! == c}; I.objeto.forEach = função (b, c, d) {para (var e em b) c.call (d, b [e], e, b)}; I.object.filter = função (b, c, d) {var e = {}, f; b) c.call (d, b [f], f, b) && (e [f] = b [f]); return e}; I.object.map = função (b, c, d) {var e = {}, f; para (f em b) e [f] = c.call (d, b [f], f, b); retorno e}; I.object.some = função (b, c, d) {para (var e em b) se (c.call (d, b [e], e, b)) return! 0; return! 1}; I.object.every = function (b, c, d ) {para (var e em b) se (! c.call (d, b [e], e, b)) retorna! 1; return! 0};
I.object.er = função (b) {var c = 0, d; para (d em b) c ++; retorno c}; I.objeto.cr = função (b) {para (var c em b) retorno c } Iobject.dr = function (b) {para (var c em b) return b [c]}; I.object.contains = function (b, c) {retorno I.object.Yi (b, c Iobject.ur = function (b) {var c = [], d = 0, e; para (e em b) c [d ++] = b [e]; retorno c}; Lf = função (b) {var c = [], d = 0, e; para (e em b) c [d ++] = e; retorno c}; I.objeto.tr = função (b, c) {var d = I.Nb (c), e = dc: argumentos; para (d = d? 0: 1; d <e.length; d ++) {if (null == b) return; b = b [e [d]]} return b};
I.object.Xi = função (b, c) {retorno nulo! == b && c em b}; I.objeto.Yi = função (b, c) {para (var d em b) se (b [d] = = c) return! 0; return! 1}; I.object.tj = função (b, c, d) {para (var e em b) if (c.call (d, b [e], e, b )) return e}; I.object.Lq = função (b, c, d) {retorno (c = I.objeto.tj (b, c, d)) && b [c]}; I.objeto.Qb = function (b) {para (var c em b) return! 1; return! 0}; I.object.clear = função (b) {para (var c em b) delete b [c]}; remove = function (b, c) {var d; (d = c em b) && delete b [c]; retorno d};
I.object.add = function (b, c, d) {if (null! == b && c in b) erro de lançamento ('O objeto já contém a chave "' + c + '"'); I.object.set ( b, c, d)}; I.object.get = função (b, c, d) {retorno nulo! == b && c em b? b [c]: d}; I.objeto.set = função (b, c, d) {b [c] = d}; I.object.xt = função (b, c, d) {retorno c em b? b [c]: b [c] = d}; Mt = função (b, c, d) {se (c em b) retornar b [c]; d = d (); retorno b [c] = d}; I.objeto.Ib = função (b, c) {para (var d em b) se (! (d em c) || ​​b [d]! == c [d]) retorna! 1; para (d em c) se (! (d em b)) retornar ! 1; return! 0};
I.object.clone = função (b) {var c = {}, d; para (d em b) c [d] = b [d]; retorno c}; I.objeto.Bl = função (b) { var c = I.ca (b); se (c == v || c == n) {se (I.Ba (b.clone)) retornar b.clone (); c = c == n? ]: {}; para (var d em b) c [d] = I.objeto.Bl (b [d]); retorno c} retorno b}; I.object.eu = função (b) {var c = {}, d; para (d em b) c [b [d]] = d; return c}; I.object.Je = ["construtor", t, "isPrototypeOf", x, A, "toString", "valor de"];
I.object.extend = function (b, c) {para (var d, e, f = 1; f <argumentos.length; f ++) {e = argumentos [f]; para (d em e) b [d] = e [d]; para (var g = 0; g <I.objeto.Je.length; g ++) d = I.objeto.Je [g], Object.prototype.hasOwnProperty.call (e, d) && ( b [d] = e [d])}}; I.object.create = function (b) {var = argumentos.length; if (1 == c && I.isArray (arguments [0])) return I.object .create.apply (null, argumentos [0]); if (c% 2) erro de lançamento ("Número ímpar de argumentos"); para (var d = {}, e = 0; e <c; e + = 2) d [argumentos [e]] = argumentos [e + 1]; retorno d};
I.object.aj = function (b) {var = argumentos.length; if (1 == c && I.isArray (arguments [0])) return I.object.aj.apply (null, argumentos [0]); para (var d = {}, e = 0; e <c; e ++) d [argumentos [e]] =! 0; retorno d}; I.objeto.lq = função (b) {var c = b; .isFrozen &&! Object.isFrozen (b) && (c = Object.create (b), Object.freeze (c)); retorno c}; I.object.Tr = função (b) {return !! Object.isFrozen && Object. isFrozen (b)};
I.object.ar = function (b, c, d) {se (! B) return []; if (! Object.getOwnPropertyNames ||! Object.getPrototypeOf) retorna I.object.Lf (b); para (var e = {}; b && (b! == Object.prototype || c) && (b! == Função.prototipo || d);) {para (var f = Object.getOwnPropertyNames (b), g = 0; g <f.length; g ++) e [f [g]] =! 0; b = Object.getPrototypeOf (b)} retornar I.object.Lf (e)}; IguserAgent.w = {}; IguserAgent.w. Gg = function () {retornar IguserAgent.AK ("Opera")}; IguserAgent.w.Hk = function () {retornar IguserAgent.AK ("Trident") || IguserAgent.AK ("MSIE")}; IguserAgent. w.Od = function () {return IguserAgent.AK ("Edge")}; IguserAgent.w.Gk = function () {retornar IguserAgent.AK ("Firefox")}; IguserAgent.w.Hg = function () { return IguserAgent.AK ("Safari") &&! (IguserAgent.w.Md () || IguserAgent.w.Nd () || IguserAgent.w.Gg () || IguserAgent.w.Od () || IguserAgent.w.zg () || IguserAgent.AK ("Android"))};
IguserAgent.w.Nd = function () {return IguserAgent.AK ("Coast")}; IguserAgent.w.Ik = função () {return (IguserAgent.AK ("iPad") || IguserAgent.AK ("iPhone" )) &&! IguserAgent.w.Hg () &&! IguserAgent.w.Md () &&! IguserAgent.w.Nd () && I.g.userAgent.AK ("AppleWebKit")}; IguserAgent.w.Md = função () {return (IguserAgent.AK ("Chrome") || IguserAgent.AK ("CriOS")) &&! IguserAgent.w.Od ()};
IguserAgent.w.Fk = function () {return IguserAgent.AK ("Android") &&! (IguserAgent.w.ng () || IguserAgent.w. $ J () || IguserAgent.w.Kd () || IguserAgent.w.zg ())}; IguserAgent.w.Kd = IguserAgent.w.Gg; IguserAgent.w.rc = IguserAgent.w.Hk; IguserAgent.w.Ra = IguserAgent.w.Od; IguserAgent.w. $ j = IguserAgent.w.Gk; IguserAgent.w.hs = IguserAgent.w.Hg; IguserAgent.w.Nr = IguserAgent.w.Nd; IguserAgent.w.Vr = IguserAgent.w.Ik; IguserAgent.w.ng = IguserAgent.w.Md; IguserAgent.w.Kr = IguserAgent.w.Fk;
IguserAgent.w.zg = function () {return IguserAgent.AK ("Silk")}; IguserAgent.w.Lb = function () {função b (b) {b = Ijfind (b, e); retorno d [b ] || ""} var c = IguserAgent.A.pb (); if (IguserAgent.w.rc ()) retorna IguserAgent.w.Dj (c); c = IguserAgent.A.rf (c); var d = {}; IjforEach (c, função (b) {d [b [0]] = b [1]}); var e = I.eb (I.objeto.Xi, d); retorno IguserAgent.w.Kd ()? b (["Version", "Opera"]): IguserAgent.w.Ra ()? b (["Borda"]): IguserAgent.w.ng ()? b (["Chrome", "CriOS "]): (c = c [2]) && c [1] ||" "};
IguserAgent.w.xa = function (b) {retorno 0 <= IfDb (IguserAgent.w.Lb (), b)}; IguserAgent.w.Dj = função (b) {var c = / rv: * ([\ d \.] *) /. exec (b); if (c && c [1]) retorna c [1]; c = ""; var d = / MSIE + ([\ d \.] +) /. exec ( b); if (d && d [1]) if (b = / Tridente \ / (\ d. \ d) /. exec (b), "7.0" == d [1]) se (b && b [1]) alternar (b [1]) {caso "4.0": c = "8.0"; quebra; caso "5.0": c = "9.0"; quebra; caso "6.0": c = "10.0"; quebra; caso "7.0" : c = "11.0"} else c = "7.0"; caso contrário c = d [1]; return c}; IguserAgent.V = {}; IguserAgent.V.ik = function () {return IguserAgent.AK ("Presto ")}; IguserAgent.V.lk = function () {return IguserAgent.AK (" Trident ") || IguserAgent.AK (" MSIE ")}; IguserAgent.V.Ra = function () {return IguserAgent.AK ( "Edge")}; IguserAgent.V.Bg = function () {return IguserAgent.A.Ig ("WebKit") &&! IguserAgent.V.Ra ()}; IguserAgent.V.ak = função () {return IguserAgent.AK ("Gecko") &&! IguserAgent .V.Bg () &&! IguserAgent.V.lk () &&! IguserAgent.V.Ra ()};
IguserAgent.V.Lb = function () {var b = IguserAgent.A.pb (); if (b) {b = IguserAgent.A.rf (b); var c = IguserAgent.V.Bj (b); (c) retornar "Gecko" == c [0]? IguserAgent.V.Mj (b): c [1]; b = b [0]; var d; se (b && (d = b [2]) && (d = / Trident \ / ([^ \ s;] +) /. exec (d))) retornar d [1]} retornar ""}; IguserAgent.V.Bj = function (b) {if (! IguserAgent .V.Ra ()) return b [1]; para (var c = 0; c <b.length; c ++) {var d = b [c]; se ("Borda" == d [0]) retorno d}}; IguserAgent.V.xa = função (b) {retorno 0 <= IfDb (IguserAgent.V.Lb (), b)};
IguseAgent.V.Mj = function (b) {retorno (b = Ijfind (b, função (b) {retorno "Firefox" == b [0]})) && b [1] || ""}; I.async .fh = função (b) {I.global.setTimeout (function () {lance b;}, 0)}; I.async.qa = função (b, c, d) {var e = b; c && (e = I.bind (b, c)); e = I.async.qa.oh (e); I.Ba (I.global.setImmediate) && (d || I.async.qa.Fl ())? I.global.setImmediate (e) :( I.async.qa.Xg || (I.async.qa.Xg = I.async.qa.Ij ()), I.async.qa.Xg (e)) }; I.async.qa.Fl = function () {return I.global.Window && I.global.Window.prototype &&! IguserAgent.w.Ra () && I.global.Window.prototype.setImmediate == I.global.setImmediate ?! 1:! 0};
I.async.qa.Ij = function () {var b = I.global.MessageChannel; "indefinido" === typeof b && "indefinido"! == janela typeof && window.postMessage && window.addEventListener &&! IguserAgent.V.ik () && (b = function () {var b = document.createElement ("IFRAME"); b.style.display = "nenhum"; b.src = ""; document.documentElement.appendChild (b); var c = b. contentWindow; b = c.document; b.open (); b.write (""); b.close (); var d = "callImmediate" + Math.random (), e = "file:" == c .location.protocol? "*": c.location.protocol + "//" + c.location.host; b = I.bind (função (b) {if (("*" ==
e || b.origin == e) && b.data == d) this.port1.onmessage ()}, isto); c.addEventListener ("mensagem", b,! 1); this.port1 = {}; this.port2 = {postMessage: function () {c.postMessage (d, e)}}}; if ("indefinido"! == tipo de b &&! IguserAgent.w.rc ()) {var = novo b, d = {}, e = d; c.port1.onmessage = função () {if (IW (d.next)) {d = d.next; var b = d.bf; d.bf = null; )}}; return function (b) {e.next = {bf: b}; e = e.next; c.port2.postMessage (0)}} return "undefined"! == tipo de documento && "onreadystatechange" no documento Função .createElement (k)? (b) {var c = document.createElement (k);
c.onreadystatechange = function () {c.onreadystatechange = null; c.parentNode.removeChild (c); c = nulo; b (); b = nulo}; document.documentElement.appendChild (c)}: function (b) {I.global.setTimeout (b, 0)}}; I.async.qa.oh = ILVj; I.debug.aa.register (função (b) {I.async.qa.oh = b}); .async.Ga = function () {this.Lc = this.yb = nulo}; I.async.Ga.Qc = 100; I.async.Ga.Kb = novo I.async.Xb (function () {return novo I.async.Yc}, função (b) {b.reset ()}, I.async.Ga.Qc); I.async.Ga.prototype.add = função (b, c) {var d = I .async.Ga.Kb.get (); d.set (b, c); this.Lc? this.Lc.next = d: this.yb = d; this.Lc = d}; I.async.Ga .prototype.remove = function () {var b = nulo; this.yb && (b = this.yb, this.yb = this.yb.next, this.yb || (this.Lc = nulo), b.next = null); return b}; I.async.Yc = function () {this.next = this.scope = this.nd = nulo};
I.async.Yc.prototype.set = function (b, c) {this.nd = b; this.scope = c; this.next = null}; I.async.Yc.prototype.reset = function () { this.next = this.scope = this.nd = null}; I.wh =! 1; I.async.O = função (b, c) {I.async.O.Ec || I.async.O. Wj (); I.async.O.Kc || (I.async.O.Ec (), I.async.O.Kc =! 0); I.async.O.de.add (b, c) }; I.async.O.Wj = function () {if (I.wh || I.global.Promise && I.global.Promise.resolve) {var b = I.global.Promise.resolve (void 0); .async.O.Ec = function () {b.then (I.async.O.Ac)}} mais I.async.O.Ec = function () {I.async.qa (I.async.O. Ac)}}; I.async.O.Nq = function (b) {I.async.O.Ec = função () {I.async.qa (I.async.O.Ac); b && b (I.async .O.Ac)}}; I.async.O.Kc =! 1; I.async.O.de = novo I.async.Ga;
IZ && (I.async.O.bt = function () {I.async.O.Kc =! 1; I.async.O.de = novo I.async.Ga}); I.async.O.Ac = function () {para (var b; b = I.async.O.de.remove ();) {tentar {b.nd.call (b.scope)} catch (c) {I.async.fh (c }} I.async.Ga.Kb.put (b)} I.async.O.Kc =! 1}; Iao = {}; IaoFp = C (); IaoZc = B (); Iaovp = C (); IaoDi = função (b) {retorno IaoZc (b)}; IaoBp = C (); IaoAp = C (); Iaowp = C (); IaoEp = C (); IaoFi = função (b) {retorno IaoZc (b) Iaoxp = C (); IaoEi = função (b) {retorno IaoZc (b)}; Iaao = C (); Iaozp = C (); IaoCp = C (); IaoDp = C (); Iaovq = função ( b) {retorno I.ka (b)? b.constructor.displayName || b.constructor.name || Object.prototype.toString.call (b): void 0 === b? "indefinido": null == = b? "null": typeof b};
Iaonc = function (b) {return (b = b && b.ownerDocument) && (b.defaultView || b.parentWindow) || I.global}; IguserAgent.platform = {}; IguserAgent.platform.mg = function () { return IguserAgent.AK ("Android")}; IguserAgent.platform.wg = function () {retornar IguserAgent.AK ("iPod")}; IguserAgent.platform.vg = function () {retornar IguserAgent.AK ("iPhone" ) &&! IguserAgent.AK ("iPod") &&! IguserAgent.AK ("iPad")}; IguserAgent.platform.ug = function () {retornar IguserAgent.AK ("iPad")}; IguserAgent.platform.tg = function () {return IguserAgent.platform.vg () || IguserAgent.platform.ug () || IguserAgent.platform.wg ()};
IguserAgent.platform.xg = function () {retornar IguserAgent.AK ("Macintosh")}; IguserAgent.platform.fk = function () {retornar IguserAgent.AK ("Linux")}; IguserAgent.platform.Dg = function ( ) {return IguserAgent.AK ("Windows")}; IguserAgent.platform.og = function () {retornar IguserAgent.AK ("CrOS")}; IguserAgent.platform.Mr = function () {return IguserAgent.AK (" CrKey ")}; IguserAgent.platform.dk = function () {return IguserAgent.A.Ig (" KaiOS ")};
IguserAgent.platform.Lb = function () {var b = IguserAgent.A.pb (), c = ""; IguserAgent.platform.Dg ()? (C = / Windows (?: NT | Telefone) ([0- 9.] +) /, C = (b = c.exec (b))? B [1]: "0.0"): IguserAgent.platform.tg ()? (C = / (?: iPhone | iPod | iPad | CPU) \ s + OS \ s + (\ S +) /, c = (b = c.exec (b)) && b [1] .replace (/ _ / g, ".")): IguserAgent.platform.xg ()? (c = / Mac OS X ([0-9 _.] +) /, c = (b = c.exec (b))? b [1] .replace (/ _ / g, ".") : "10"): IguserAgent.platform.mg ()? (C = / Android \ s + ([^ \);] +) (\) |;) /, c = (b = c.exec (b)) && b [1]): IguserAgent.platform.og () && (c = / (?: CrOS \ s + (?: i686 | x86_64) \ s + ([0-9.] +)) /,
c = (b = c.exec (b)) && b [1]); return c || ""}; IguserAgent.platform.xa = function (b) {retorno 0 <= IfDb (IguserAgent.platform.Lb () b)}; I.Ia = {}; I.I.objeto = funç˜ao (b, c) {retorno c}; I.Ia.Xd = funç˜ao (b) {I.Ia.Xd [""] ( b); return b}; I.Ia.Xd [""] = I.cb; I.Ia.Sp = função (b, c) {try {return I.I.Xd (b [c])! 0} catch (d) {} ​​retornar! 1}; I.Ia.cache = function (b, c, d, e) {e = e? E (c): c; return Objeto.prototipo.hasOwnProperty.call ( b [e] = d (c)}; I.userAgent = {}; he =! 1; I.userAgent.ne =! 1; I.userAgent.Pc =! 1; I.userAgent.le =! 1; I.userAgent.th =! 1; I.userAgent.zb = I.userAgent .ie || I.userAgent.ge || I.userAgent.he || I.userAgent.Pc || I.userAgent.ne || I.userAgent.le; I.userAgent.Lj = função () {return IguserAgent .A.pb ()}; I.userAgent.zd = function () {retorno I.global.navigator || nulo}; I.userAgent.nr = function () {retorno I.userAgent.zd ()}; I.userAgent.He = I.userAgent.zb? I.userAgent.le: IguserAgent.w.Kd ();
I.userAgent. $ = I.userAgent.zb? I.userAgent.ie: IguserAgent.w.rc (); I.userAgent.ue = I.userAgent.zb? I.userAgent.ge: IguserAgent.V.Ra ( ); I.userAgent.Mm = I.userAgent.ue || I.userAgent. $; I.userAgent.Tc = I.userAgent.zb? I.userAgent.he: IguserAgent.V.ak (); I.userAgent .Bb = I.userAgent.zb? I.userAgent.ne || I.userAgent.Pc: IguserAgent.V.Bg (); I.userAgent.hk = function () {retorno I.userAgent.Bb && I.g.userAgent .AK ("Mobile")}; I.userAgent.Vn = I.userAgent.Pc || I.userAgent.hk (); I.userAgent.uo = I.userAgent.Bb;
I.userAgent.hj = function () {var b = I.userAgent.zd (); retorno b && b.platform || ""}; I.userAgent.ko = I.userAgent.hj (); I.userAgent.ke =! 1; I.userAgent.oe =! 1; I.userAgent.je =! 1; I.userAgent.pe =! 1; I.userAgent.fe =! 1; I.userAgent.Nc =! 1; .userAgent.Mc =! 1; I.userAgent.Oc =! 1; I.userAgent.vh =! 1; I.userAgent.za = I.userAgent.ke || I.userAgent.oe || I.userAgent. je || I.userAgent.pe || I.userAgent.fe || I.userAgent.Nc || I.userAgent.Mc || I.userAgent.Oc; I.userAgent.Mn = I.userAgent.za? .userAgent.ke: IguserAgent.platform.xg ();
I.userAgent.gp = I.userAgent.za? I.userAgent.oe: IguserAgent.platform.Dg (); I.userAgent.ek = function () {retornar IguserAgent.platform.fk () || IguserAgent.platform. og ()}; I.userAgent.Kn = I.userAgent.za? I.userAgent.je: I.userAgent.ek (); I.userAgent.qk = function () {var b = euuserAgent.zd ( ); return !! b && I.f.contains (b.appVersion || "", "X11")}; I.userAgent.hp = I.userAgent.za? I.userAgent.pe: I.userAgent.qk () ; I.userAgent.Ul = I.userAgent.za? I.userAgent.fe: IguserAgent.platform.mg ();
I.userAgent.yn = I.userAgent.za? I.userAgent.Nc: IguserAgent.platform.vg (); I.userAgent.xn = I.userAgent.za? I.userAgent.Mc: IguserAgent.platform.ug ( ); I.userAgent.zn = I.userAgent.za? I.userAgent.Oc: IguserAgent.platform.wg (); I.userAgent.wn = I.userAgent.za? I.userAgent.Nc || I.userAgent .Mc || I.userAgent.Oc: IguserAgent.platform.tg (); I.userAgent.Cn = I.userAgent.za? I.userAgent.vh: IguserAgent.platform.dk ();
I.userAgent.ij = function () {var b = "", c = eu.usuárioA.nj (); c && (b = c? C [1]: ""); retorno I.userAgent. $ && (c = I.userAgent.Ef (), nulo! = C && c> parseFloat (b))? Cadeia (c): b}; I.userAgent.Nj = function () {var b = I.userAgent.Lj (); se (I.userAgent.Tc) return / rv: ([^ \);] +) (\) |;) /. Exec (b); se (I.userAgent.ue) retornar / Borda \ / ([\ d \.] +) /. exec (b); if (retorno.user.agente. $) / \ b (?: MSIE | rv) [:] ([^ \);] +) (\) |;) / .exec (b); se (I.userAgent.Bb) retornar / WebKit \ / (\ S +) /. exec (b); se (I.userAgent.He) retornar / (?: Versão) [\ /]? (\ S +) /. Exec (b)};
I.userAgent.Ef = function () {var b = I.global.document; retorno b? B.documentMode: void 0}; I.userAgent.VERSION = I.userAgent.ij (); I.userAgent.compare = function (b, c) {retorno IfDb (b, c)}; I.userAgent.nk = {}; I.userAgent.xa = function (b) {retorno I.userAgent.th || I.Ia.cache ( I.userAgent.nk, b, function () {return 0 <= IfDb (I.userAgent.VERSION, b)})}; I.userAgent.ns = I.userAgent.xa; I.userAgent.Pb = function ( b) {return Número (I.userAgent.Nh)> = b}; I.userAgent.Pr = I.userAgent.Pb; var J; var K = I.global.document, ba = I.userAgent.Ef () ;
J = K & I.userAgent. $? Ba || ("CSS1Compat" == K.compatMode? ParseInt (eu.userAgent.VERSION, 10): 5): void 0; I.userAgent.Nh = J; Iagb = {Bh :! I.userAgent. $ || I.userAgent.Pb (9), Ch:! I.userAgent.Tc &&! I.userAgent. $ || I.userAgent. $ && I.userAgent.Pb (9) || I .userAgent.Tc && I.userAgent.xa ("1.9.1"), re: I.userAgent. $ &&! I.userAgent.xa ("9"), Dh: I.userAgent. $ || I.userAgent.He || I.userAgent.Bb, Th: I.userAgent. $, Gn: I.userAgent. $ &&! I.userAgent.Pb (9)}; Iatags = {}; Iatags.xi = {area:! 0, base:! 0, br:! 0, col:! 0, comando:! 0, incorporação:! 0, hr:! 0, img:! 0, entrada:! 0, keygen:! 0, link:! 0, meta:! 0, param:! 0, fonte:! 0, faixa:! 0, wbr:! 0}; Iatags.pk = função (b) {return! 0 === Iatags.xi [b]}; $ o = C (); IfH = função (b, c) {this.ae = b === IfHze && c || ""; this.mi = IfHOe}; IfHprototype.wa =! 0; IfHprototype.ja = D ( "ae");prototype.toString = function () {return "Const {" + this.ae + "}"}; IfHs = função (b) {if (b instanceof IfH && b.constructor === IfH && b.mi === IfHOe) return b. ae; Ioha ("objeto esperado do tipo Const, obtido '" + b + "'"); retorno "type_error: Const"}; IfHfrom = function (b) {return novo IfH (IfHze, b)}; IfHOe = {} ; IfHze = {}; IfHEMPTY = IfHfrom (""); Ib = {}; IbN = function () {this.wc = ""; this.ci = IbNda}; IbNprototype.wa =! 0; IbNda = {} ; IbNjc = função (b) {b = IfHs (b); retorno 0 === b.length? IbNEMPTY: IbNEb (b)}; IbNRq = função (b, c) {para (var d = [], e = 1; e <argumentos.length; e ++) d.push (IbNbh (argumentos [e])); retorno IbNEb ("(" + IfHs (b) + ") (" + d.join (",") + ");")}; IbNvq = função (b) {retorno IbNEb (IbNbh (b))}; IbNprototype.ja = D ("wc"); IZ && (IbNprototype.toString = function () {retornar "SafeScript {" + this.wc + "}"});
IbNs = function (b) {if (b instanceof IbN && b.constructor === IbN && b.ci === IbNda) return b.wc; Ioha ("objeto esperado do tipo SafeScript, obtido '" + b + a + I.ca (b)); return "type_error: SafeScript"}; IbNbh = function (b) {retornar JSON.stringify (b) .replace (/ </ g, "\\ x3c")}; IbNEb = função (b) { retorno (novo IbN) .ab (b)}; IbNprototype.ab = função (b) {this.wc = b; retornar isto}; IbNEMPTY = IbNEb (""); I.ua = {}; I.ua. url = {}; I.ua.url.Zi = função (b) {retorno I.ua.url.bg (). createObjectURL (b)}; I.ua.url.ct = função (b) {I. ua.url.bg (). revokeObjectURL (b)}; I.ua.url.bg = function () {var b = I.ua.url.vf (); if (null! = b) retorno b; Erro ("Este navegador não parece suportar URLs de blobs");}; I.ua.url.vf = function () {return IW (I.global.URL) && I.W (I.global.URL.createObjectURL ) I.global.URL: IW (I.global.webkitURL) && I.W (I.global.webkitURL.createObjectURL)? I.global.webkitURL: IW (I.global.createObjectURL)? I.global: nulo};
I.ua.url.Pp = function () {return null! = I.ua.url.vf ()}; Ih = {}; Ihi = {}; IhiQh =! 1;
IhiCe = IhiQh || ("ar" == ISsubstring (0,2) .toLowerCase () || "fa" == ISsubstring (0,2) .toLowerCase () || "he" == ISsubstring (0,2 ) .toLowerCase () || "iw" == ISsubstring (0,2) .toLowerCase () || "ps" == ISsubstring (0,2) .toLowerCase () || "sd" == ISsubstring (0, 2) .toLowerCase () || "ug" == ISsubstring (0,2) .toLowerCase () || "ur" == ISsubstring (0,2) .toLowerCase () || "yi" == ISsubstring (0 , 2) .toLowerCase ()) && (2 == ISlength || "-" == ISsubstring (2,3) || "_" == ISsubstring (2,3)) || 3 <= ISlength && "ckb" == ISsubstring (0,3) .toLowerCase () &&
(3 == ISlength || "-" == ISsubstring (3,4) || "_" == ISsubstring (3,4)) || 7 <= ISlength && "ff" == ISsubstring (0,2). toLowerCase () && ("-" == ISsubstring (2,3) || "_" == ISsubstring (2,3)) && ("adlm" == ISsubstring (3,7) .toLowerCase () || " arab "== ISsubstring (3,7) .toLowerCase ()); Ihikb = {Vh:" \ u202a ", Zh:" \ u202b ", ou seja:" \ u202c ", Wh:" \ u200e ", $ h: "\ u200f"} IhiR = {Ta: 1, Ua: -1, sa: 0}; Ihi $ b = "direita"; IhiYb = "esquerda"; Ihirn = IhiCe? IhiYb: Ihi $ b; Ihiqn = IhiCe Ihi $ b: IhiYb;
Ihiul = função (b) {return typeof b == u? 0 <b? IhiRTa: 0> b? IhiRUa: IhiRsa: null == b? Null: b? IhiRUa: IhiRTa}; Ihisb = "A-Za-z \ u00c0- \ u00d6 \ u00d8- \ u00f6 \ u00f8- \ u02b8 \ u0300- \ u0590 \ u0900- \ u1fff \ u200e \ u2c00- \ ud801 \ ud804- \ ud839 \ ud83c- \ udbff \ uf900- \ ufb1c \ ufe00- \ ufe6f \ ufefd- \ uffff "; Ihixb =" \ u0591- \ u06ef \ u06fa- \ u08ff \ u200f \ ud802- \ ud803 \ ud83a- \ ud83b \ ufb1d- \ ufdff \ ufe70- \ ufefc "; IhiTj = / < [^>] *> | & [^;] +; / g; IhiSa = função (b, c) {retorno c? b.replace (IhiTj, ""): b};
IhiUk = new RegExp ("[" + Ihixb + "]"); Ihizk = novo RegExp ("[" + Ihisb + "]"); IhiBd = função (b, c) {retornar IhiUk.test (IhiSa (b, c) Ihiyr = IhiBd; Ihieg = function (b) {retornar Ihizk.test (IhiSa (b, void 0))}; IhiCk = new RegExp ("^ [" + Ihisb + "]"); IhiZk = new RegExp ( "^ [" + Ihixb + "]"); Ihijk = função (b) {retorno IhiZk.test (b)}; Ihigk = função (b) {retorno IhiCk.test (b)}; Ihi $ r = função (b ) {return! Ihigk (b) &&! Ihijk (b)}; IhiAk = new RegExp ("^ [^" + Ihixb + "] * [" + Ihisb + "]");
IhiWk = new RegExp ("^ [^" + Ihisb + "] * [" + Ihixb + "]"); Ihi $ g = função (b, c) {retornar IhiWk.test (IhiSa (b, c))}; Ihigs = Ihi $ g; Ihinl = function (b, c) {retornar IhiAk.test (IhiSa (b, c))}; IhiYr = Ihinl; Ihiyg = / ^ http: \ / \ /.*/; Ihibs = function ( b, c) {b = IhiSa (b, c); retorno Ihiyg.test (b) ||! Ihieg (b) &&! IhiBd (b)}; IhiBk = new RegExp ("[" + Ihisb + "] [^ "+ Ihixb +"] * $ "); IhiXk = novo RegExp (" ["+ Ihixb +"] [^ "+ Ihisb +"] * $ "); Ihilj = função (b, c) {return IhiBk.test (IhiSa ( b, c))};
IhiXr = Ihilj; Ihimj = função (b, c) {retornar IhiXk.test (IhiSa (b, c))}; Ihies = Ihimj; IhiYk = / ^ (ar | ckb | dv | ele | iw | fa | nqo | ps | sd | ug | ur | yi |. * [-_] (Adlm | árabe | Hebr | Thaa | Nkoo | Tfng)) (?!. * [-_] (Latn | Cyrl) ($ | - | _ )) ($ | - | _) / i; Ihifs = function (b) {retornar IhiYk.test (b)}; IhiOi = / (\ (. *? \) +) | (\ [. *? \] +) | (\ {. *? \} +) | (<. *?> +) / g; Ihixr = funç˜ao (b, c) {c = (void 0 === c? IhiBd (b): c ) Ihikb. $ H: Ihikb.Wh; return b.replace (IhiOi, c + "$ &" + c)};
IhiEq = function (b) {return "<" == b.charAt (0)? B.replace (/ <\ w + /, "$ & dir = rtl"): "\ n <span dir = rtl>" + b + "</ span>"}; IhiFq = função (b) {retorno Ihikb.Zh + b + Ihikb.Ie}; IhiCq = função (b) {retorno "<" == b.charAt (0)? b. substituir (/ <\ w + /, "$ & dir = ltr"): "\ n <span dir = ltr>" + b + "</ span>"}; IhiDq = função (b) {retorno Ihikb.Vh + b + Ihikb.Ie}; Ihijj = /: \ s * ([. \ D] [. \ W] *) \ s + ([. \ D] [. \ W] *) \ s + ([. \ D] [ . \ w] *) \ s + ([. \ d] [. \ w] *) / g; Ihirk = / esquerda / gi; IhiTk = / direita / gi; Ihisl = / %%%% / g;
Ihixs = function (b) {retorno b.replace (Ihijj, ": $ 1 $ 4 $ 3 $ 2"). Substitua (Ihirk, "%%%%"). Substitua (IhiTk, IhiYb) .replace (Ihisl, Ihi $ b) }; Ihikj = / ([\ u0591- \ u05f2]) "/ g; Ihill = / ([\ u0591- \ u05f2]) '/ g; IhiCs = função (b) {return b.replace (Ihikj," $ 1 \ u05f4 "). replace (Ihill," $ 1 \ u05f3 ")}; IhiKl = / \ s + /; IhiSj = / [\ d \ u06f0- \ u06f9] /; IhiVk = .4;
Ihipf = função (b, c) {var d = 0, e = 0, f =! 1; b = IhiSa (b, c) .split (IhiKl); para (c = 0; c <b.length; c ++ ) {var g = b [c]; Ihi $ g (g)? (d ++, e ++): Ihiyg.test (g)? f =! 0: Ihieg (g)? e ++: IhiSj.test (g) && ( f =! 0)} retorno 0 == e? f? IhiRTa: IhiRsa: d / e> IhiVk? IhiRUa: IhiRTa}; Ihixq = funï¿½o (b, c) {retorno Ihipf (b, c) == IhiRUa}; Ihirt = function (b, c) {b && (c = Ihiul (c)) && (b.style.textAlign = c == IhiRUa? Ihi $ b: IhiYb, b.dir = c == IhiRUa? "Rtl": "ltr")};
Ihist = função (b, c) {troca (Ihipf (c)) {caso IhiRTa: b.dir = "ltr"; quebra; caso IhiRUa: b.dir = "rtl"; quebra; padrão: b.removeAttribute (" dir ")}}; IhiLm = C (); IbC = funo () {this.zc =" "; este.oi = IbCda}; IbCprototype.wa =! 0; IbCprototype.ja = D (" zc "); IbCprototype.Dd =! 0; IbCprototype.Za = function () {retorno IhiRTa}; IZ && (IbCprototype.toString = function () {retorno "TrustedResourceUrl {" + this.zc + "}"}); IbCs = função (b) {if (b instanceof IbC && b.constructor === IbC && b.oi === IbCda) return b.zc; Ioha ("objeto esperado do tipo TrustedResourceUrl, obtido '" + b + a + I.ca (b)); "type_error: TrustedResourceUrl"};
IbCformat = function (b, c) {var d = IfHs (b); if (! IbCyh.test (d)) erro de lançamento ("Formato TrustedResourceUrl inválido:" + d); b = d.replace (IbCRh, function ( b, f) {if (! Object.prototype.hasOwnProperty.call (c, f)) Erro de lançamento ('Marcador encontrado', '+ f +' ", em formato string," '+ d +' ", mas nenhum rótulo válido mapeamento encontrado em args: '+ JSON.stringify (c)); b = c [f]; return b instanceof IfH? IfHs (b): encodeURIComponent (Cadeia (b))}); return IbCHb (b)}; = /% {(\ w +)} / g; IbCyh = / ^ (?: https:)? \ / \ / [0-9a-z.: [\] -] + \ / | ^ \ / [^ \ / \\] | ^ about: blank # / i;
IbCsi = / ^ ([^? #] *) (\? [^ #] *)? (# [\ S \ S] *)? /; IbCOq = função (b, c, d, e) {b = IbCformat (b, c); b = IbCs (b); b = IbCsi.exec (b); c = b [3] || ""; return IbCHb (b [1] + IbCah ("?", B [ 2] || "", d) + IbCah ("#", c, e))}; IbCjc = função (b) {retornar IbCHb (IfHs (b))}; IbCSq = função (b) {for (var c = "", d = 0; d <b.length; d ++) c + = IfHs (b [d]); retorno IbCHb (c)}; IbCda = {}; IbCHb = funo (b) {var c = novo IbC; c.zc = b; return c};
IbCah = função (b, c, d) {se (null == d) retornar c; se (IM (d)) retornar b + encodeURIComponent (d); para (var e em d) {var f = d [e ]; f = I.isArray (f)? f: [f]; para (var g = 0; g <f.length; g ++) {var h = f [g]; null! = h && (c + = (c "&": b) + encodeURIComponent (e) + "=" + encodeURIComponent (String (h)))}} return c}; Ibl = function () {this.Ha = ""; this.fi = Iblda} Iblga = "about: invalid # zClosurez"; Iblprototype.wa =! 0; Iblprototype.ja = D ("Ha"); Iblprototype.Dd =! 0; Iblprototype.Za = function () {retorno IhiRTa}; IZ && ( Iblprototype.toString = function () {return "SafeUrl {" + this.Ha + "}"}); Ibls = função (b) {if (b instanceof Ibl && b.constructor === Ibl && b.fi === Iblda) retorno b .Ha; Ioha ("objeto esperado do tipo SafeUrl, obtido '" + b + a + I.ca (b)); retorno "type_error: SafeUrl"};l.jc = function (b) {retornar Ibloa (IfHs (b))};
IbLe = / ^ (?: áudio \ / (?: 3gpp2 | 3gpp | aac | L16 | midi | mp3 | mp4 | mpeg | oga | ogg | opus | x-m4a | x-wav | wav | webm) | imagem \ / (?: bmp | gif | jpeg | jpg | png | tiff | webp) | texto \ / csv | video \ / (?: mpeg | mp4 | ogg | webm | quicktime)) $ / i; IblQq = funï¿½o (b (b): Iblga; return Ibloa (b)}; IbIh = / ^ data: ([^ ;,] [a-z0-9 + \ /] + = * $ / i; IblTq = função (b) {b = b.replace (/ (% 0A |% 0D) / g, ""); var c = b. correspondência (IbIh); c = c & ib.Le.test (c [1]); retorno Ibloa (c? b: Iblga)};
IblZq = function (b) {Ifbd (b, "tel:") || (b = Iblga); return Ibloa (b)}; Ibji = / ^ sip [s]?: [+ A-z0-9_.! $% & '* \ / = ^ `{|} ~ -] + @ ([a-z0-9 -] + \.) + [a-z0-9] {2,63} $ / i; IblXq = função (b) {Ibji.test (decodeURIComponent (b)) || (b = Iblga); retorno Ibloa (b)}; IblUq = função (b) {Ifbd (b, "fb-messenger: // share") || (b = Iblga); retorno Ibloa (b)}; IblYq = função (b) {Ifbd (b, "sms:") && I.blkk (b) || (b = Iblga); retorno Ibloa (b) };
Iblkk = function (b) {var = b.indexOf ("#"); 0 <c && (b = b.substring (0, c)); c = b.match (/ [? &] Body = / gi ); if (! c) return! 0; if (1 <c.length) retorna! 1; b = b.match (/ [? &] body = ([^ &] *) /) [1]; (! b) return! 0; try {decodeURIComponent (b)} catch (d) {retorno! 1} return / ^ (?: [a-z0-9 \ -_. ~] |% [0-9a-f ] {2}) + $ / i.test (b)}; Iblkt = function (b, c) {retornar IblTd (/ ^ chrome-extension: \ / \ / ([^ \ /] +) \ //, b, c)}; Iblmt = function (b, c) {retornar IblTd (/ ^ moz-extensão: \ / \ / ([^ \ /] +) \ //, b, c)};
Ibllt = função (b, c) {retornar IblTd (/ ^ ms-browser-extensão: \ / \ / ([^ \ /] +) \ //, b, c)}; IblTd = função (b, c, d) {(b = b.exec (c))? (b = b [1], - 1 == (d exemplo de IfH? [IfHs (d)]: d.map (funï¿½o (b) {return IfHs ( b)})). indexOf (b) && (c = Iblga)): c = Iblga; retorno Ibloa (c)}; Ibl $ q = função (b) {retorno Ibloa (IbCs (b))}; / ^ (? :( ?: https? | mailto | ftp): | [^: /? #] * (?: [/? #] | $)) / i; Iblvo = IbWc;
IblDc = function (b) {se (b instanceof Ibl) retornar b; b = typeof b == v && b.wa? B.ja (): Seqüência (b); IbWc.test (b) || (b = Iblga) ; return Ibloa (b)}; Iblra = function (b) {se (b instanceof Ibl) retornar b; b = typeof b == v && b.wa? b.ja (): String (b); IbWc.test (b ) || (b = Iblga); retorno Ibloa (b)}; Iblda = {}; Ibloa = função (b) {var c = novo Ibl; c.Ha = b; retorno c}; IblPl = Ibloa ("sobre : em branco "); Ibv = função () {this.yc =" "; this.ei = Ibvda}; Ibvprototype.wa =! 0; Ibvda = {}; Ibvjc = função (b) {b = IfHs (b) return 0 === b.length? IbvEMPTY: IbvFb (b)}; IbvYp = C (); Ibvprototype.ja = D ("yc"); IZ && (Ibvprototype.toString = function () {retorno "SafeStyle {" + this.yc + "}"}); Ibvs = função (b) {if (b instanceof Ibv && b.constructor === Ibv && b.ei === Ibvda) return b.yc; Ioha ("objeto esperado do tipo SafeStyle, obteve '"+ b + a + I.ca (b)); retorno" type_error: SafeStyle "}; IbvFb = função (b) {return (novo Ibv) .ab (b)};
Ibvprototype.ab = function (b) {this.yc = b; return this}; IbvEMPTY = IbvFb (""); Ibvga = "zClosurez"; Ibvcreate = funç˜ao (b) {var c = "", d; for ( d em b) {se (! / ^ [-_a-zA-Z0-9] + $ /. teste (d)) Erro de lançamento ("Nome permite somente [-_a-zA-Z0-9], obteve:" + d); var e = b [d]; null! = e && (e = I.isArray (e)? Ijmap (e, IbvTg) .join (""): IbvTg (e), c + = d + ":" + e + ";")} return c? IbvFb (c): IbvEMPTY};
IbvTg = function (b) {return b instância de Ibl? 'Url ("' + Ibls (b) .replace (/ </ g,"% 3c "). Replace (/ [\\"] / g, "\\ $ & ") + '")': b instância de IfH? IfHs (b): Ibvcl (Seqüência (b))};
Ibvcl = function (b) {var c = b.replace (Ibvie, "$ 1"). Substitua (Ibvie, "$ 1"). Substitua (IbvPe, "url"); se (Ibvui.test (c)) {se (IbvGh.test (b)) return Ioha ("Valor da string não permite comentários, tem:" + b), Ibvga; if (! IbvPj (b)) retorna Ioha ("Valor da string requer aspas balanceadas, tem:" + b) , Ibvga; if (! IbvQj (b)) return Ioha ("Valor da cadeia requer colchetes equilibrados e um identificador por par de colchetes, obtido:" + b), Ibvga} else return Ioha ("Valor da cadeia permite somente" + IbvSe + "e funções simples, tenho:" +
b), Ibvga; retornar Ibvdl (b)}; IbvPj = function (b) {para (var c =! 0, d =! 0, e = 0; e <b.length; e ++) {var f = b. charAt (e); "'" == f && d? c =! c:' "'== f && c && (d =! d)} retorno c && d}; IbvQj = function (b) {para (var c =! 0, d = / ^ [-_a-zA-Z0-9] $ /, e = 0; e <b.length; e ++) {var = b.charAt (e); se ("]" == f) {se (c) retorne! 1; c =! 0} else if ("[" == f) {se (! c) retorna! 1; c =! 1} else if (! c &&! d.test (f)) return! 1} return c}; IbvSe = "[- ,. \" '% _! # a-zA-Z0-9 \\ [\\]] "; Ibvui = novo RegExp (" ^ "+ IbvSe +" + $ "); IbvPe = / \ b (url \ ([\ t \ n] *) ('[- & (- \ [\] - ~] *' |" [! # - \ [\] - ~] * "| [! # - & * - \ [\] - ~] *) ([\ t \ n] * \)) / g;
Ibvye = / \ b (hsl | hsla | rgb | rgba | matriz | calc | minmax | ajuste de conteúdo | repetição | (girar | escala | traduzir) (X | Y | Z | 3d)?) \ ([- + * / 0-9a-z.% \ [\],] + \) / G; IbvGh = / \ / \ * /; Ibvdl = function (b) {retorno b.replace (IbvPe, função (b, d, e , f) {var c = ""; e = e.replace (/ ^ (['"]) (. *) \ 1 $ /, função (b, d, e) {c = d; retorno e}} b = IblDc (e) .ja (); retorno d + c + b + c + f})}; Ibvconcat = funç˜ao (b) {funç˜ao c (b) {I.isArray (b)? IjforEach (b, c): d + = Ibvs (b)} var d = ""; IjforEach (arguments, c); return d? IbvFb (d): IbvEMPTY}; IbP = function () {this.xc = ""; this.di = IbPda}; IbPprototype.wa =! 0; IbPda = {};
IbPnq = função (b, c) {if (Ifcontains (b, "<")) Erro de lançamento ("Seletor não permite '<', obtido:" + b); var d = b.replace (/ ('| ") ((?! \ 1) [^ \ r \ n \ f \\] | \\ [\ s \ S]) * \ 1 / g," "); if (! / ^ [-_A-zA -Z0-9 #.: *,> + ~ [\] () = ^ $ |] + $ /. Teste (d)) Erro de lançamento ("Seletor permite apenas [-_a-zA-Z0-9 # .: *,> + ~ [\\] () = ^ $ |] e strings, tem: "+ b); if (! IbPOj (d)) erro de lançamento (" () e [] no seletor deve ser balanceado, tem : "+ b); c exemplo de Ibv || (c = Ibvcriar (c)); b = b +" {"+ Ibvs (c) +"} "; retornar IbPGb (b)};
IbPOj = função (b) {para (var c = {"(": ")", "[": "]"}, d = [], e = 0; e <b.length; e ++) {var f = b [e]; if (c [f]) ​​d.push (c [f]), senão se (I.objeto.contains (c, f) && d.pop ()! = f) return! 1} return 0 = = Comprimento}; IbPconcat = funç˜ao (b) {funç˜ao c (b) {I.éArray (b) IjforEach (b, c): d + = IbPs (b)} var d = ""; IjforEach ( argumentos, c); retorno IbPGb (d)}; IbPjc = função (b) {b = IfHs (b); retorno 0 === b.length? IbPEMPTY: IbPGb (b)}; IbPprototype.ja = D (" xc "); IZ && (IbPprototype.toString = function () {retornar" SafeStyleSheet {"+ this.xc +"} "});
IbPs = function (b) {if (b instanceof IbP && b.constructor === IbP && b.di === IbPda) retorno b.xc; Ioha ("objeto esperado do tipo SafeStyleSheet, got '" + b + a + I.ca (b)); return "type_error: SafeStyleSheet"}; IbPGb = função (b) {return (novo IbP) .ab (b)}; IbPprototype.ab = função (b) {this.xc = b; return this} ; IbPEMPTY = IbPGb (""); Ibm = função () {this.Ha = ""; this.bi = Ibmda; this.hc = nulo}; Ibmprototype.Dd =! 0; Ibmprototype.Za = D ("hc Ibmprototype.wa =! 0; Ibmprototype.ja = D ("Ha"); IZ && (Ibmprototype.toString = function () {retornar "SafeHtml {" + this.Ha + "}"}); Ibms = function ( b) {if (b instanceof Ibm && b.constructor === Ibm && b.bi === Ibmda) return b.Ha; Ioha ("objeto esperado do tipo SafeHtml, got '" + b + a + I.ca (b)) ;Retorna"type_error: SafeHtml "};
Ibmva = função (b) {se (b instância de Ibm) retornar b; var c = tipo de b == v, d = nulo; c && b.Dd && (d = b.Za ()); retorno Ibmta (Ifva (c && b.wa b b.ja (): Seqüência (b)), d)}; IbmBr = função (b) {se (b instância de Ibm) retornar b; b = Ibmva (b); retorno Ibmta (IfMg (Ibms (b)) , b.Za ())}; IbmCr = função (b) {se (b instância de Ibm) retornar b; b = Ibmva (b); retorno Ibmta (IfJl (Ibms (b)), b.Za ())} Ibmfrom = Ibmva; IbmRe = / ^ [a-zA-Z0-9 -] + $ /; Ibmri = {ação:! 0, cite:! 0, dados:! 0, formation:! 0, href:! 0 , manifesto:! 0, cartaz:! 0, src:! 0};
IbmYh = {APPLET:! 0, BASE:! 0, EMBED:! 0, IFRAME:! 0, LINK:! 0, MATH:! 0, META:! 0, OBJETO:! 0, SCRIPT:! 0, ESTILO: ! 0, SVG:! 0, MODELO:! 0}; Ibmcriar = função (b, c, d) {IbmHl (Seqüência (b)); retorno IbmYa (Seqüência (b), c, d)}; IbmHl = função (b) {if (! IbmRe.test (b)) erro de lançamento ("Invalid tag name <" + b + ">."); if (b.toUpperCase () em IbmYh) throw Error ("Tag name <" + b + "> não é permitido para SafeHtml.");};
Ibmkq = função (b, c, d, e) {b && I.bcs (b); var f = {}; f.src = b || nulo; f.srcdoc = c && I.bms (c); b = Ibmfc ( f, {sandbox: ""}, d); return IbmYa ("iframe", b, e)}; Ibmoq = função (b, c, d, e) {if (! IbmRi ()) Erro de Lançamento ("O o navegador não suporta iframes em sandbox. "); var f = {}; f.src = b? Ibls (IblDc (b)): nulo; f.srcdoc = c || null; f.sandbox =" "; b = Ibmfc (f, {}, d); retorne IbmYa ("iframe", b, e)}; IbmRi = function () {retorne I.global.HTMLIFrameElement && "sandbox" em I.global.HTMLIFrameElement.prototype};
Ibmqq = função (b, c) {IbCs (b); b = Ibmfc ({src: b}, {}, c); retorno IbmYa ("script", b)}; Ibmpq = função (b, c) { para (var d em c) {var e = d.toLowerCase (); se ("idioma" == e || "src" == e || "texto" == e || "tipo" == e) throw Error ('Não é possível definir' '+ e +' "atributo ');} d =" "; b = Ijconcat (b); para (e = 0; e <b.length; e ++) d + = IbNs (b [e ]) b = Ibmta (d, IhiRsa), retorno IbmYa ("script", c, b)};
Ibmrq = função (b, c) {c = Ibmfc ({tipo: "texto / css"}, {}, c); var d = ""; b = Ijconcat (b); para (var e = 0; e <b.length; e ++) d + = IbPs (b [e]); b = Ibmta (d, IhiRsa); retorno IbmYa ("estilo", c, b)}; Ibmmq = funo (b, c) {b = Ibls (IblDc (b)); (IguserAgent.w.rc () || IguserAgent.w.Ra ()) && I.f.contains (b, ";") && (b = "'" + b.replace ( / '/ g, "% 27") + "'"); return IbmYa ("meta", {"http-equiv": "atualizar", conteúdo: (c || 0) + "; url =" + b })};
Ibmwj = função (b, c, d) {se (d instância de IfH) d = IfHs (d); senão se ("estilo" == c.toLowerCase ()) d = IbmJj (d); senão {if (/ ^ on / i.test (c)) erro de lançamento ('Atributo "' + c + '" requer goog.string.Const valor, "' + d + '" fornecido.'); if (c.toLowerCase () em Ibmri) if (d instanceof IbC) d = IbCs (d); senão se (d instância de Ibl) d = Ibls (d); senão se (IM (d)) d = IblDc (d) .ja (); "Atributo" '+ c +' "na etiqueta" '+ b +' "requer goog.html.SafeUrl, goog.string.Const, ou string, valor" '+ d +' "dado. ');} D.wa && (d = d.ja ());
return c + '= "' + Ifva (Seqüência (d)) + '"'}; IbmJj = function (b) {if (! I.ka (b)) erro de lançamento (atributo "O estilo" requer goog.html .SafeStyle ou mapa de propriedades de estilo, '+ typeof b + "dado:" + b); b instanceof Ibv || (b = Ibvrear (b)); return Ibvs (b)}; Ibmtq = function (b, c, d , e) {c = Ibmcriar (c, d, e); c.hc = b; retorno c};
Ibmconcat = função (b) {função c (b) {I.éArray (b)? Para todo (b, c): (b = Ibmva (b), e + = Ibms (b), b = b.Za (), d == IhiRsa? d = b: b! = IhiRsa && d! = b && (d = null))} var d = IhiRsa, e = ""; IjforEach (argumentos, c); return Ibmta (e, d)}; Ibmgq = função (b, c) {var d = Ibmconcat (Ijslice (argumentos, 1)); d.hc = b; retorno d}; Ibmda = {}; Ibmta = função (b, c) {retorno (novo Ibm) .ab (b, c)}; Ibmprototype.ab = function (b, c) {this.Ha = b; this.hc = c; retorna isto};
IbmYa = função (b, c, d) {var e = nulo; var f = "<" + b + Ibmpl (b, c); I.bb (d)? IisArray (d) || (d = [d]): d = []; Iatags.pk (b.toLowerCase ())? f + = ">" :( e = Ibmconcat (d), f + = ">" + Ibms (e) + "</" + b + ">", e = e.Za ()); (b = c & c.dir) && (e = / ^ (ltr | rtl | auto) $ / i.test (b) "IhiRsa: nulo"; Ibmta (f, e)}; Ibmpl = função (b, c) {var d = ""; if (c) para (var e em c) {if (! IbmRe.test (e)) Erro de lançamento ('Inválido nome do atributo "'+ e +'". '); var f = c [e]; I.bb (f) && (d + = "" + Ibmwj (b, e, f))} retorno d};
Ibmfc = função (b, c, d) {var e = {}, f; para (f em b) e [f] = b [f]; para (f in c) e [f] = c [f] ; para (f in d) {var g = f.toLowerCase (); se (g in b) lançar Erro (atributo 'Impossível anular' '+ g +' ", tem" '+ f +' "com valor" '+ d [f] + '' '; g em c && delete e [g]; e [f] = d [f]} return e}; IbmIm = Ibmta ("<! DOCTYPE html>", IhiRsa); IbmEMPTY = Ibmta ( "" IhiRsa); Ibmqe = Ibmta ("<br>", IhiRsa); IaI = {}; IaIBn = {Sl: "afterbegin", Tl: "afterend", hm: "beforebegin", im: "beforeend" }; IaIEr = function (b, c, d) {b.insertAdjacentHTML (c, Ibms (d))}; IaIii = {MATEM:! 0, SCRIPT:! 0, ESTILO:! 0, SVG:! 0, MODELO :! 0}; IaIck = ILQi (function () {if (IZ && "undefined" === tipo de documento) return! 1; var b = document.createElement ("div");innerHTML = "<div> <div> </ div> </ div>"; if (IZ &&! b.firstChild) retorna! 1; var c = b.firstChild.firstChild; b.innerHTML = ""; devolução! c .parentElement});
IaICl = função (b, c) {if (IaIck ()) para (; b.lastChild;) b.removeChild (b.lastChild); b.innerHTML = c}; IaIYg = função (b, c) {if ( Ioma && I.aIii [b.tagName.toUpperCase ()]) Erro de lançamento ("goog.dom.safe.setInnerHtml não pode ser usado para definir conteúdo de" + b.tagName + "."); IaICl (b, Ibms (c)) }; IaIFt = função (b, c) {b.outerHTML = Ibms (c)}; IaIvt = função (b, c) {c = c instância de Ibl? C: Iblra (c); IaoEi (b) .action = Ibls (c)}; IaIpt = funo (b, c) {c = c exemplo de Ibl? C: Iblra (c); IaoDi (b) .formAction = Ibls (c)};
IaIBt = função (b, c) {c = c instância de Ibl? C: Iblra (c); IaoFi (b) .formAction = Ibls (c)}; IaIHt = função (b, c) {b.style.cssText = Ibvs (c)}; IaIAq = função (b, c) {b.write (Ibms (c))}; IaInt = função (b, c) {c = c instância de Ibl? C: Iblra (c); href = Ibls (c)}; IaIAt = função (b, c) {c = c instância de Ibl? c: Iblra (c); b.src = Ibls (c)}; IaIot = função (b, c) {c = c instanceof Ibl? c: Iblra (c); b.src = Ibls (c)}; IaILt = function (b, c) {c = c instanceof Ibl? c: Iblra (c); b.src = Ibls ( c)};
IaItt = função (b, c) {b.src = IbCs (c)}; IaIwt = função (b, c) {b.src = IbCs (c)}; IaIyt = função (b, c) {b.src = IbCs (c)}; IaIzt = função (b, c) {b.srcdoc = Ibms (c)}; IaCt = função (b, c, d) {b.rel = d; Ifaf (d, "folha de estilo" )? b.href = IbCs (c): b.href = c exemplo de IbC? IbCs (c): c instância de Ibl? Ibls (c): Iblra (c) .ja ()}; IaIEt = função (b, c ) {b.data = IbCs (c)}; IaIil = função (b, c) {b.src = IbCs (c); (c = I.Zf ()) && b.setAttribute ("nonce", c)} ;
IaIGt = função (b, c) {b.text = IbNs (c); (c = I.Zf ()) && b.setAttribute ("nonce", c)}; IaIDt = função (b, c) {c = c instanceof Ibl? c: Iblra (c); b.href = Ibls (c)}; IaILp = funç˜ao (b, c) {c = c instanceof Ibl? c: Iblra (c); b.assignifica (Ibls (c) ) IaI $ s = function (b, c) {c = c instanceof Ibl? C: Iblra (c); b.replace (Ibls (c))}; IaIKs = função (b, c, d, e , f) {b = b instância de Ibl? b: Iblra (b); retorno (c || janela) .open (Ibls (b), d? IfHs (d): "", e, f)}; Ibfb = {}; Ibfb. $ K = função (b, c) {retorno Ibmta (c, nulo)}; Ibfb.gt = função (b, c) {retorno IbNEb (c)}; Ibfb.ht = função (b, c) {retorno IbvFb (c)}; Ibfb.it = função (b, c) {retorno IbPGb (c)}; Ibfb.jt = função (b, c) {retorno Ibloa (c)}; Ibfb.gu = função (b, c) {retornar IbCHb (c)}; Iu = {}; IuPs = função (b) {retornar Math.floor (Math.random () * b)}; Iuiu = função (b, c) { return b + Math.random () * (cb)};IUZp = função (b, c, d) {retornar Math.min (Math.max (b, c), d)}; IuKg = função (b, c) {b% = c; retorno 0> b * c? b + c: b}; Iuqs = função (b, c, d) {retorno b + d * (cb)}; IuBs = função (b, c, d) {retorno Math.abs (bc) <= (d || 1E-6)}; Iu $ d = função (b) {retorno IuKg (b, 360)}; IuSt = função (b) {retorno IuKg (b, 2 * Math.PI)}; Iujh = função ( b) {retorno b * Math.PI / 180}; Iutl = função (b) {retorno 180 * b / Math.PI};
Iunp = função (b, c) {retorno c * Math.cos (Iujh (b))}; Iuop = função (b, c) {retorno c * Math.sin (Iujh (b))}; Iuangle = função ( b, c, d, e) {retorno Iu $ d (Iutl (Math.atan2 (ec, db)))); Iump = função (b, c) {b = I ud (c) -Iu d ( b); 180 <b = b = 360: -180> = b && (b = 360 + b); retorno b}; Iusign = função (b) {retorno 0 <b? 1: 0> b? -1: b};
Ius = função (b, c, d, e) {d = d || função (b, c) {retorno b == c}; e = e || função (c) {retorno b [c]}; (var f = b.length, g = c.length, h = [], l = 0; l <f + 1; l ++) h [l] = [], h [l] [0] = 0; (var m = 0; m <g + 1; m ++) h [0] [m] = 0; para (l = 1; l <= f; l ++) para (m = 1; m <= g; m ++) d (b [l-1], c [m-1])? h [l] [m] = h [l-1] [m-1] +1: h [l] [m] = Math.max (h [l-1] [m], h [l] [m-1]), var r = []; l = f; para (m = g; 0 <l && 0 <m;) d (b [l -1], c [m-1])? (R.unshift (e (l-1, m-1)), l -, m -): h [l-1] [m]> h [ l] [m-1]? l -: m -; retorno r}; Iube = função (b) {return Ijreduce (argumentos, função (b, d) {retorno b + d}, 0)};
IuIi = function (b) {return Iube.apply (nulo, argumentos) /arguments.length}; Iubl = function (b) {var = argument.length; if (2> c) retorna 0; var d = IuIi. apply (null, arguments); return Iube.apply (nulo, Ijmap (argumentos, função (b) {retornar Math.pow (bd, 2)})) / (c-1)}; IuTt = function (b) { return Math.sqrt (Iubl.apply (nulo, argumentos))}; IuUr = função (b) {retorno éFinito (b) && 0 == b% 1}; IuSr = função (b) {retorno éFinito (b)}; IuZr = função (b) {retorno 0 == b && 0> 1 / b};
Iuts = function (b) {se (0 <b) {var = Math.round (Math.log (b) * Math.LOG10E); retorno c- (parseFloat ("1e" + c)> b? 1: 0)} return 0 == b? -Infinity: NaN}; Iuet = function (b, c) {retornar Math.floor (b + (c || 2E-15))}; Iudt = function (b, c) { return Math.ceil (b- (c || 2E-15))}; IuX = function (b, c) {this.x = IW (b)? b: 0; isto.y = IW (c)? c : 0}; IuXprototype.clone = function () {retornar novo IuX (this.x, this.y)}; IZ && (IuXprototype.toString = function () {return "(" + this.x + "," + isto. y + ")"}); IuXprototype.Ib = function (b) {retorno b instanceof IuX && I.uXIb (this, b)}; IuXIb = function (b, c) {retorno b == c?! 0: b && c? bx == cx && b.y == cy:! 1}; IuXzq = função (b, c) {var d = bx-cx; b = by-cy; retorno Math.sqrt (d * d + b * b)}; IuXvs = function (b) {retornar Math.sqrt (bx * b.x + by * by)};
IuXazimuth = função (b) {return Iuangle (0,0, bx, by)}; IuXQt = função (b, c) {var d = bx-cx; b = by-cy; retorno d * d + b * b }; IuXyq = function (b, c) {retorna o novo IuX (bx-cx, by-cy)}; IuXbe = function (b, c) {retorna o novo IuX (b.x + cx, b.y + cy) }; F = IuXprototype; F.ceil = function () {this.x = Math.ceil (this.x); this.y = Math.ceil (this.y); retorne isto}; F.floor = function ( ) {this.x = Math.floor (this.x); this.y = Math.floor (this.y); retorne isto}; F.round = function () {this.x = Math.round (isto. x); this.y = Math.round (this.y); devolva isto};
F.translate = function (b, c) {b instância de IuX? (This.x + = bx, this.y + = by) :( this.x + = Número (b), I.Rb (c) && (this.y + = c)); retorne isto}; F.scale = function (b, c) {c = I.Rb (c)? c: b; this.x * = b; this.y * = c; return this} Iulb = função (b, c) {this.width = b; this.height = c}; Iulb.Ib = função (b, c) {retorno b == c?! 0: b && c? B.width == c.width && b.height == c.height:! 1}; Iulb.prototype.clone = function () {retornar novo Iulb (this.width, this.height)}; IZ && (Iulb.prototype.toString = function () {return "(" + this.width + "x" + this.height + ")"}); F = Iulb.prototype; F.zi = function () {retornar this.width * this.height}; F.aspectRatio = function () {retornar this.width / this.height}; F.Qb = function () {retorno! this.zi ()};
F.ceil = function () {this.width = Math.ceil (this.width); this.height = Math.ceil (this.height); retorne isto}; F.floor = function () {this.width = Math.floor (this.width); this.height = Math.floor (this.height); retorna este}; F.round = function () {this.width = Math.round (esta.width); = Math.round (this.height); retorne isto}; F.scale = function (b, c) {c = I.Rb (c)? C: b; this.width * = b; this.height * = c; devolva isto; Iaxh =! 1; Iame =! 1; IaHh = Iaxh || Iame; Iatd = function (b) {retorno b? new Iajb (IaQa (b)): Iagj || (Iagj = new Iajb ) Iaxj = função () {documento de retorno}; Iaud = função (b) {retorno Iaxd (documento, b)}; Iaxd = função (b, c) {retorno IM (c)? B.getElementById (c) : IaFj = função (b) {retorno IaYf (documento, b)}; IaYf = função (b, c) {retorno Iaxd (b, c)}; Iaph = Iaud; IagetElementsByTagName = função (b, c) {return (c || document) .getElementsByTagName (String (b))};
Iayd = função (b, c, d) {retorno Iakc (documento, b, c, d)}; IaAj = função (b, c, d) {retorno Iawd (documento, b, c, d)}; IaHf = função (b, c) {var d = c || documento; retorno Iaad (d)? d.querySelectorAll ("." + b): Iakc (documento, "*", b, c)}; Iavd = função ( b, c) {var d = c || documento; retorno (d.getElementsByClassName? d.getElementsByClassName (b) [0]: Iawd (documento, "*", b, c)) || nulo}; IaXf = função (b, c) {retornar Iavd (b, c)}; Iaad = função (b) {return! (! b.querySelectorAll ||! b.querySelector)};
Iakc = função (b, c, d, e) {b = e || b; c = c && "*"! = C? Cadeia (c) .toUpperCase (): ""; if (Iaad (b) && ( c || d)) retorna b.querySelectorAll (c + (d? "." + d: "")); if (d && b.getElementsByClassName) {b = b.getElementsByClassName (d); if (c) {e = { } para (var f = 0, g = 0, h; h = b [g]; g ++) c == h.nodeName && (e [f ++] = h); e.length = f; retorno e} retorno b } b = b.getElementsByTagName (c || "*"); if (d) {e = {}; para (g = f = 0; h = b [g]; g ++) c = h.className, typeof c .split == p && I.j.contains (c.split (/ \ s + /), d) && (e [f ++] = h); e.length = f; retorno e} retorno b};
Iawd = função (b, c, d, e) {var f = e || b, g = c && "*"! = C? Cadeia (c) .toUpperCase (): ""; return Iaad (f) && ( g || d)? f.querySelector (g + (d? "." + d: "")): Iakc (b, c, d, e) [0] || null}; Iaqh = Iayd; IaGc = função (b, c) {I.object.forEach (c, função (c, e) {c && tipoof c == v && c.wa && (c = c.ja ()); "estilo" == e? b.style.cssText = c: "class" == e? b.className = c: "para" == e? b.htmlFor = c: Iate.hasOwnProperty (e)? b.setAttribute (Iate [e], c): IfstartsWith ( e, "aria -") || IfstartsCom (e, "data -")? b.setAttribute (e, c): b [e] = c})};
Iate = {cellpadding: "cellPadding", cellpacing: "cellSpacing", colspan: "colSpan", frameborder: "frameBorder", altura: "altura", maxlength: "maxLength", nonce: "nonce", papel: "role" , rowspan: "rowSpan", tipo: "tipo", usemap: "useMap", valign: "vAlign", largura: "largura"}; Iacg = função (b) {return Iadg (janela b ||)}; = função (b) {b = b.document; b = IaOb (b)? b.documentElement: b.body; return novo Iulb (b.clientWidth, b.clientHeight)}; Iayj = função () {return Iard ( window)}; Iagr = function (b) {return Iard (b)};
Iard = function (b) {var = b.document, d = 0; if (c) {d = c.body; var e = c.documentElement; if (! E ||! D) retornar 0; b = Iadg (b) .height; if (IaOb (c) && e.scrollHeight) d = e.scrollHeight! = B? E.scrollHeight: e.offsetHeight; mais {c = e.scrollHeight; var f = e.offsetHeight; e .clientHeight! = f && (c = d.scrollHeight, f = d.offsetHeight); d = c> b? c> f? c: f: c <f? c: f}} retorno d}; Iapr = funo ( b) {retorno Iatd ((b || I.global || janela) .documento) .Ff ()}; IaFf = function () {return IaGf (documento)};
IaGf = função (b) {var c = Iasd (b); b = Ianc (b); retorno I.userAgent. $ && I.userAgent.xa ("10") && b.pageYOffset! = C.scrollTop? New IuX ( c.scrollLeft, c.scrollTop): novo IuX (b.pageXOffset || c.scrollLeft, b.pageYOffset || c.scrollTop)}; Iazj = function () {return Iasd (documento)}; Iasd = função (b ) {return b.scrollingElement? b.scrollingElement:! I.userAgent.Bb && I.a.Ob (b)? b.documentElement: b.body || b.documentElement}; Iaqb = função (b) {return b? Ianc (b): window}; Ianc = function (b) {retorno b.parentWindow || b.defaultView};
Iaed = função (b, c, d) {retorno Iahf (documento, argumentos)}; Iahf = função (b, c) {var d = Cadeia (c [0]), e = c [1]; if (! Iagb.Bh && e && (e.name || e.type)) {d = ["<", d]; e.name && d.push ('nome = "', Ifva (e.name), '"'); (e.type) {d.push ('type = "', Ifva (e.type), '"'); var f = {}; I.object.extend (f, e); delete f.type; e = f} d.push (">"); d = d.join ("")} d = b.createElement (d); e && (IM (e)? d.className = e: I.isArray (e )? d.className = e.join (""): IaGc (d, e)); 2 <c.length & i.a.Ue (b, d, c, 2); retorno d};
IaUe = função (b, c, d, e) {função f (d) {d & c.appendChild (IM (d)? B.createTextNode (d): d)} para (; e <d.length; e ++) { var g = d [e]; I.Nb (g) &&! IaId (g)? IjforEach (IaJd (g)? Ijih (g): g, f): f (g)}}; Iarh = Iaed; IacreateElement = função (b) {return IaNa (documento, b)}; IaNa = função (b, c) {retorno b.createElement (String (c))}; IacreateTextNode = função (b) {return document.createTextNode (String b))}; Iabj = função (b, c, d) {retorno Iajf (documento, b, c, !! d)};
Iajf = função (b, c, d, e) {para (var f = IaNa (b, "TABELA"), g = f.appendChild (IaNa (b, "TBODY")), h = 0; h <c ; h ++) {para (var l = IaNa (b, "TR"), m = 0; m <d; m ++) {var r = IaNa (b, "TD"); e && I.a.Vd (r, IfQe L.appendChild (r)} g.appendChild (l)} return f}; Iahq = function (b) {var c = Ijmap (argumentos, IfHs); c = Ibfb. $ K (IfHfrom ("Constante") Sequência HTML, que é transformada em um Nó mais tarde, então será automaticamente balanceada. "), C.join (" ")); return IaRg (c)}; IaRg = function (b) {return IaSg (documento, b )};
IaSg = função (b, c) {var d = IaNa (b, "DIV"); Iagb.Th?(IaIYg(d,Ibmconcat(Ibmqe,c)), d.removeChild (d.firstChild)): IaIYg ( d, c); return IaUi (b, d)}; IaUi = function (b, c) {if (1 == c.childNodes.length) return c.removeChild (c.firstChild); para (b = b. createDocumentFragment (); c.firstChild;) b.appendChild (c.firstChild); retorno b}; IaYj ​​= function () {retorno IaOb (documento)}; IaOb = função (b) {retorno IaHh? Iame: "CSS1Compat" == b.compatMode}; IacanHaveChildren = function (b) {se (b.nodeType! = Iafa.Ja) retornar! 1; switch (b.tagName) {caso "APPLET": caso "AREA": caso "BASE" : caso "BR": caso "COL": caso "COMMAND": caso "EMBED": caso "FRAME": caso "HR": caso "IMG": caso "INPUT": caso "IFRAME": caso "ISINDEX" : caso "KEYGEN":caso "LINK": caso "NOFRAMES": caso "NOSCRIPT": caso "META": caso "OBJECT": caso "PARAM": caso k: caso "SOURCE": caso "STYLE": caso "TRACK": caso " WBR ": return! 1} return! 0};
IaappendChild = função (b, c) {b.appendChild (c)}; Iaappend = função (b, c) {IaUe (IaQa (b), b, argumentos, 1)}; IaSd = função (b) {para ( var c; c = b.firstChild;) b.removeChild (c)}; Iajg = função (b, c) {c.parentNode && c.parentNode.insertBefore (b, c)}; Iaig = função (b, c) { c.parentNode && c.parentNode.insertBefore (b, c.nextSibling)}; Iahg = função (b, c, d) {b.insertBefore (c, b.childNodes [d] || null)}; IaremoveNode = function (b ) {return b && b.parentNode? b.parentNode.removeChild (b): nulo};
IaQg = função (b, c) {var d = c.parentNode; d && d.replaceChild (b, c)}; Iawf = função (b) {var c, d = b.parentNode; if (d && d.nodeType! = Iafa .Mh) {if (b.removeNode) return b.removeNode (! 1); para (; c = b.firstChild;) d.insertBefore (c, b); retorno IaremoveNode (b)}}; IaDf = function ( b) {return Iagb.Ch && void 0! = b.children? b.children: Ijfilter (b.childNodes, função (b) {retorno b.nodeType == Iafa.Ja})}; IaIf = function (b) {return IW (b.firstElementChild)? B.firstElementChild: Ialc (b.firstChild,! 0)};
IaMf = function (b) {retorno IW (b.lastElementChild)? B.lastElementChild: Ialc (b.lastChild,! 1)}; IaOf = função (b) {retorno IW (b.nextElementSibling)? B.nextElementSibling: Ialc (b.nextSibling,! 0)}; IaVf = função (b) {return IW (b.previousElementSibling)? b.previousElementSibling: Ialc (b.previousSibling,! 1)}; Ialc = function (b, c) {para (; b && b.nodeType! = Iafa.Ja;) b = c? b.nextSibling: b.previousSibling; retorno b};
IAPF = function (b) {if return null; if (b.firstChild) retornar b.firstChild; para (; b && b.nextSibling;) b = b.parentNode; retorno b b.nextSibling (b!):? Nula }; IaWf = function (b) {if nulo retorno (b!); if (! b.previousSibling) retornar b.parentNode; para (b = b.previousSibling; b && b.lastChild;) b = b.lastChild; retorno b }; IAID = função (b) {return I.ka (b) && 0 <b.nodeType}; IAFD = função (b) {return I.ka (b) && b.nodeType == Iafa.Ja}; IACG = função (b) {retorno I.ka (b) && b.window == b};
IaUf = function (b) {var c; if (Iagb.Dh &&! (I.userAgent. $ && I.userAgent.xa ("9") &&! I.userAgent.xa ("10") && I.global.SVGElement && b instanceof I.global.SVGElement) && (c = b.parentElement)) return c; c = b.parentNode; retorno IaFd (c)? C: nulo}; Iacontains = função (b, c) {if (! B || ! c) return! 1; if (b.contains && c.nodeType == Iafa.Ja) return b == c || b.contains (c); if ("indefinido"! = typeof b.compareDocumentPosition) retorno b == c || !! (b.compareDocumentPosition (c) & 16); para (; c && b! = c;) c = c.parentNode; retorno c == b};
Iacf = function (b, c) {se (b == c) retornar 0; se (b.compareDocumentPosition) retornar b.compareDocumentPosition (c) & 2? 1: -1; if (I.userAgent. $ &&! I. userAgent.Pb (9)) {if (b.nodeType == Iafa.Sc) return-1; if (c.nodeType == Iafa.Sc) retorna 1} if ("sourceIndex" em b || b.parentNode && " sourceIndex "em b.parentNode) {var d = b.nodeType == Iafa.Ja, e = c.nodeType == Iafa.Ja; if (d && e) retorna b.sourceIndex-c.sourceIndex; var f = b.parentNode , g = c.parentNode; retorno f == g? Iaef (b, c):! d && I.a.contains (f, c)? - 1 * Iadf (b, c):! e && I.a.contains (g b) Iadf (c,
b): (d? b.sourceIndex: f.sourceIndex) - (e? c.sourceIndex: g.sourceIndex)} e = IaQa (b); d = e.createRange (); d.selectNode (b); d .collapse (! 0); b = e.createRange (); b.selectNode (c); b.collapse (! 0); retorno d.compareBoundaryPoints (I.global.Range.START_TO_END, b)}; Iadf = função (b, c) {var d = b.parentNode; se (d == c) return-1; para (; c.parentNode! = d;) c = c.parentNode; retorno Iaef (c, b)}; Iaef = função (b, c) {para (; c = c.previousSibling;) if (c == b) return-1; return 1};
Iasf = function (b) {var c, d = argumentos.length; if (! D) retorna null; if (1 == d) retorna argumentos [0]; var e = [], f = Infinito; = 0; c <d; c ++) {para (var g = [], h = argumentos [c]; h;) g.unshift (h), h = h.parentNode; e.push (g); f = Math.min (f, g.length)} g = null; para (c = 0; c <f; c ++) {h = e [0] [c]; para (var l = 1; l <d; l ++ ) if (h! = e [l] [c]) return g; g = h} return g}; IaQa = function (b) {retorno b.nodeType == Iafa.Sc? b: b.ownerDocument || b .document}; IaJf = function (b) {return b.contentDocument || b.contentWindow.document};
IaKf = function (b) {try {retornar b.contentWindow || (b.contentDocument? Iaqb (b.contentDocument): nulo)} catch (c) {} retornar nulo}; IaVd = função (b, c) {se ("textContent" em b) b.textContent = c; else if (b.nodeType == Iafa.ac) b.data = Cadeia (c); else if (b.firstChild && b.firstChild.nodeType == Iafa.ac) {for (; b.lastChild! = b.firstChild;) b.removeChild (b.lastChild); b.firstChild.data = String (c)} mais {IaSd (b); var d = IaQa (b); .appendChild (d.createTextNode (String (c)))}};
IaTf = function (b) {if ("outerHTML" em b) retorna b.outerHTML; var c = IaQa (b); c = IaNa (c, "DIV"); c.appendChild (b.cloneNode (! 0) ); return c.innerHTML}; Iatf = function (b, c) {var d = []; retorno Iamd (b, c, d, 0)? d [0]: void 0}; Iauf = function (b c) {var d = []; Iamar (b, c, d, 1); retorno d}; Iaa = função (b, c, d, e) {se (nulo! = b) para (b = b.firstChild; b;) {se (c (b) && (d.push (b), e) || Iamd (b, c, d, e)) retornar! 0; b = b.nextSibling} retornar! 1}; IaNe = {SCRIPT: 1, ESTILO: 1, HEAD: 1, IFRAME: 1, OBJETO: 1}; IaZb = {IMG: "", BR: "\ n"};
IaHd = função (b) {retorno Iafg (b) && I.a.Ag (b)}; IaWg = função (b, c) {c? B.tabIndex = 0: (b.tabIndex = -1, b.removeAttribute ("tabIndex")); Iapg = função (b) {var c; retorno (c = IaKk (b) ?! b.disabled && (! Iafg (b) || IaAg (b)): IaHd (b)) && I.userAgent. $? IaRj (b): c}; Iafg = função (b) {return eu.userAgent. $ &&! I.userAgent.xa ("9")? (B = b.getAttributeNode ("tabindex" ), I.bb (b) && b.specified): b.hasAtributo ("tabindex")}; IaAg = função (b) {b = b.tabIndex; retorno I.Rb (b) && 0 <= b && 32768> b} ;
IaKk = function (b) {retorno "A" == b.tagName || "INPUT" == b.tagName || "TEXTAREA" == b.tagName || "SELECT" == b.tagName || "BOTÃO "== b.tagName}; IaRj = function (b) {b =! I.Ba (b.getBoundingClientRect) || I.userAgent. $ && null == b.parentElement? {altura: b.offsetHeight, largura: b .offsetWidth}: b.getBoundingClientRect (); retorno I.bb (b) && 0 <b.height && 0 <b.width};
Iamc = function (b) {if (Iagb.re e& null! == b && "innerText" em b) b = IfTi (b.innerText); senão {var c = []; IaAd (b, c,! 0); = c.join ("")} b = b.replace (/ \ xAD / g, "") .replace (/ \ xAD / g, ""); b = b.replace (/ \ u200B / g, " "); Iagb.re || (b = b.replace (/ + / g," "));" "! = B && (b = b.replace (/ ^ \ s * /," ")); b}; Iasr = função (b) {var c = []; IaAd (b, c,! 1); retorno c.join ("")};
IaAd = function (b, c, d) {se (! (B.nodeName em IaNe)) if (b.nodeType == Iafa.ac) d? C.push (Cadeia (b.nodeValue) .replace (/ ( \ r \ n | \ r | \ n) / g, "")): c.push (b.nodeValue); caso contrário, (b.nodeName em IaZb) c.push (IaZb [b.nodeName]); else para (b = b.firstChild; b;) IaAd (b, c, d), b = b.nextSibling}; IaRf = função (b) {retorno Iamc (b) .comprimento}; IaSf = função (b, c ) {c = c || IaQa (b) .body; para (var d = []; b && b! = c;) {para (var e = b; e = e.previousSibling;) d.unshift (Iamc (e )); b = b.parentNode} return IftrimLeft (d.join ("")). replace (/ + / g, "") .length};
IaQf = função (b, c, d) {b = [b]; para (var e = 0, f = nulo; 0 <comprimento leve && e <c;) se (f = b.pop (),! (F .nodeName em IaNe)) if (f.nodeType == Iafa.ac) {var g = f.nodeValue.replace (/ (\ r \ n | \ r | \ n) / g, ""). substituir (/ + / g, ""); e + = g.length} mais if (f.nodeName em IaZb) e + = IaZb [f.nodeName] .length; else para (g = f.childNodes.length-1; 0 <= g;) b.push (f.childNodes [g]); I.ka (d) && (d.Ss = f? f.nodeValor.length + ce-1: 0, d.node = f) ; retorno f};
IaJd = function (b) {if (b && typeof b.length == u) {if (I.ka (b)) retornar typeof b.item == p || typeof b.item == y; if (I.Ba (b)) return type of b.item == p} return! 1}; Iapd = function (b, c, d, e) {if (! c &&! d) return nulo; var f = c? String (c) .toUpperCase (): null; retorno Iaod (b, function (b) {return (! f || b.nodeName == f) && (! d || IM (b.className) && I.j.contains (b. className.split (/ \ s + /), d)),, 0, e)}; IaAf = function (b, c, d) {retornar Iapd (b, null, c, d)};
Iaod = função (b, c, d, e) {b &&! D && (b = b.parentNode); para (d = 0; b && (nulo == e || d <= e);) {se (c ( b)) retorno b; b = b.parentNode; d ++} retorno nulo}; Iazf = função (b) {try {var = b & b.activeElement; retorno c && c.nodeName? c: nulo} captura (d) {retorno nulo }}; Iaqr = function () {var b = Iaqb (); retorno IW (b.devicePixelRatio)? B.devicePixelRatio: b.matchMedia? Iatc (3) || Iatc (2) || Iatc (1.5) || Iatc (1) ||, 75: 1};
Iatc = função (b) {return Iaqb (). MatchMedia ("(min-resolução:" + b + "dppx), (min-moz-device-pixel-ratio:" + b + "), (resolução mínima: "+ 96 * b +" dpi) "). Corresponde? B: 0}; IaCf = função (b) {retorno b.getContext (" 2d ")}; Iajb = função (b) {this.Y = b || I.global.document || documento}; F = Iajb.prototype; F.td = Iatd; F.xj = D ("Y"); F.ud = função (b) {return Iaxd (this.Y, b )}; F.Fj = function (b) {return IaYf (this.Y, b)}; F.ph = Iajb.prototype.ud; F.getElementsByTagName = function (b, c) {retorno (c || este .Y) .getElementsByTagName (String (b))};
F.yd = função (b, c, d) {retorno Iakc (this.Y, b, c, d)}; F.Aj = função (b, c, d) {retorno Iawd (this.Y, b, c, d)}; F.Hf = função (b, c) {retorno IaHf (b, c || this.Y)}; F.vd = função (b, c) {retorno Iavd (b, c || this.Y)}; F.Xf = função (b, c) {return IaXf (b, c || this.Y)}; F.qh = Iajb.prototype.yd; F.Gc = IaGc; F.cg = function (b) {return Iacg (b || this.qb ())}; F.yj = function () {return Iard (this.qb ())}; F.ed = função (b, c, d {return Iaah (this.Y, arguments)};
F.createTextNode = function (b) {retornar this.YcreateTextNode (String (b))}; F.bj = function (b, c, d) {retornar Iajf (this.Y, b, c, !! d )}; F.Rg = função (b) {return IaSg (this.Y, b)}; F.Yj = function () {retorno IaOb (this.Y)}; F.qb = function () {retorno Ianc (this.Y)}; F.zj = function () {retorno Iasd (this.Y)}; F.Ff = function () {retorno IaGf (this.Y)}; F.zf = function (b) { return Iazf (b || this.Y)}; F.appendChild = IaappendChild; F.append = Iaappend; F.canHaveChildren = IacanHaveChildren; F.Sd = IaSd; F.jg = Iajg; F.ig = Iaig; F. hg = Iahg;
F.removeNode = IaremoveNode; F.Qg = IaQg; F.wf = Iawf; F.Df = IaDf; F.If = IaIf; F.Mf = IaMf; F.Of = IaOf; F.Vf = IaVf; F. Pf = IaPf; F.Wf = IaWf; F.Id = IaId; F.Fd = IaFd; F.Cg = IaCg; F.Uf = IaUf; F.contains = Iacontains; F.cf = Iacf; F.sf = Iasf; F.Qa = IaQa; F.Jf = IaJf; F.Kf = IaKf; F.Vd = IaVd; F.Tf = IaTf; F.tf = Iatf; F.uf = Iauf; F.Hd = IaHd; F.Wg = IaWg; F.pg = Iapg; F.mc = Iamc; F.Rf = IaRf; F.Sf = IaSf; F.Qf = IaQf; F.Jd = IaJd; F.pd = Iapd; F. Af = IaAf; F.od = Iaod; F.Cf = IaCf; I.Pg = {}; I.Pg.so = C (); I.Thenable = C (); I.Thenable.prototype.then = C (); I.Thenable.Be = "$ goog_Thenable"; I.Thenable.Te = função (b) {b.prototype.then = b.prototype.then; b.prototype [I.Thenable.Be] =! 0 }; I.Thenable.qg = function (b) {se (! B) retornar! 1; tente {retornar !! b [I.Thenable.Be]} pegar (c) {return! 1}}; I.Promise = function (b, c) {isto.ba = I.Promise.T.ya; this.la = void 0; this.mb = this.Ma = this.ea = null; this.kd =! 1; 0 < EU.Promise.Wa? This.Jc = 0: 0 == I.Promise.Wa && (this.oc =! 1); I.Promise.Da && (this.Zd = [], L (isto, Erro ("criado") ), this.lf = 0); se (b! = lcb) tente {var d = isto; b.call (c, funç˜ao (b) {M (d, I.Promise.T.Ka, b) }, function (b) {se (IZ &&! (b instanceof I.Promise.ib)) tentar {if (b instanceof Error) lançar b; lançar Erro ("Promise rejected.");} catch (f) {} M (d, I.Promise.T.na, b)})} catch (e) {M (isto, I.Promise.T.na, e)}}; I.Promise.Da =! 1;
I.Promise.Wa = 0; I.Promise.T = {ya: 0, zh: 1, Ka: 2, nd: 3}; I.Promise.se = function () {this.next = this.context = this.tb = this.Tb = this.Xa = null; this.bc =! 1}; I.Promise.se.prototype.reset = function () {this.context = this.tb = this.Tb = isso. Xa = null; this.bc =! 1}; I.Promise.Qc = 100; I.Promise.Kb = novo I.async.Xb (function () {retornar novo I.Promise.se}, function (b) {b.reset ()}, I.Promise.Qc); I.Promise.Bf = function (b, c, d) {var e = I.Promise.Kb.get (); e.Tb = b; e .tb = c; e.context = d; return e}; I.Promise.Sk = função (b) {I.Promise.Kb.put (b)};
I.Promise.resolve = function (b) {se (b instanceof I.Promise) retornar b; var c = novo I.Promise (I.cb); M (c, I.Promise.T.Ka, b); return c}; I.Promise.reject = function (b) {retornar novo I.Promise (função (c, d) {d (b)})}; I.Promise.Bc = função (b, c, d) {I.Promise.Jg (b, c, d, nulo) || I.async.O (I.eb (c, b))}; I.Promise.race = função (b) {retornar novo I.Promise (função (c, d) {b.length || c (void 0); para (var e = 0, f; e <b.length; e ++) f = b [e], I.Promise.Bc (f ,CD)})};
I.Promise.all = function (b) {retornar novo I.Promise (função (c, d) {var e = b.length, f = []; if (e) para (var g = function (b, d ) {e -; f [b] = d; 0 == e & c (f)}, h = função (b) {d (b)}, l = 0, m; l <b.length; l ++) m = b [l], I.Promise.Bc (m, I.eb (g, l), h), senão c (f)})}; I.Promise.lp = function (b) {retorno novo I. Promise (função (c) {var d = b.length, e = []; se (d) para (var f = função (b, f, g) {d -; e [b] = f? :! 0, valor: g}: {vj:! 1, razão: g}; 0 == d & c (e)}, g = 0, h; g <b.length; g ++) h = b [g], I.Promise.Bc (h, I.eb (f, g, 0), I.eb (f, g, 1)), senão c (e)})};
I.Promise.Mq = function (b) {retornar novo I.Promise (função (c, d) {var e = b.length, f = []; se (e) para (var g = function (b) { c (b)}, h = função (b, c) {e -; f [b] = c; 0 == e & d (f)}, l = 0, m; l <b.length; l ++) m = b [l], I.Promise.Bc (m, g, I.eb (h, l)), senão c (void 0)})}; I.Promise.ou = function () {var b, c , d = novo I.Promise (função (d, f) {b = d; c = f}); retornar novo I.Promise.ai (d, b, c)}; I.Promise.prototype.then = function (b, c, d) {I.Promise.Da && L (isto, Erro ("then")); retorno ca (isso, I.Ba (b)? b: nulo, I.Ba (c)? c: null d)}; I.Thenable.Te (I.Promise);
I.Promise.prototype.cancel = function (b) {this.ba == I.Promise.T.ya && I.async.O (function () {var c = novo I.Promise.ib (b); N (este c)}, isto)}; função N (b, c) {se (b.ba == I.Promise.T.ya) if (b.ea) {var d = b.ea; if (d. Ma) {para (var e = 0, f = nulo, g = nulo, h = d.Ma; h && (h.bc || (e ++, h.Xa == b && (f = h),! (F && 1 < e)); h = h.next) f || (g = h); f && (d.ba == I.Promise.T.ya && 1 == e? N (d, c): (g? = g, e.next == d.mb && (d.mb = e), e.próxima = e.próxima.próxima): O (d), P (d, f, I.Promise.T.na, c )))} b.ea = null} mais M (b, I.Promise.T.na, c)}
função Q (b, c) {b.Ma || b.ba! = I.Promise.T.Ka && b.ba! = I.Promise.T.na || R (b); b.mb? bmb .next = c: b.Ma = c; b.mb = c} função ca (b, c, d, e) {var f = I.Promise.Bf (nulo, nulo, nulo); f.Xa = novo I.Promise (função (b, h) {f.Tb = função c (d) {try {var = c.call (e, d); b (f)} captura (r) {h (r) }}: b; f.tb = d? função (c) {try {var = d.call (e, c) ;! IW (f) &&c instanceof I.Promise.ib? h (c): b ( f)} captura (r) {h (r)}}: h}); f.Xa.ea = b; Q (b, f); retorno f.Xa} I.Promise.prototype.xl = function (b ) {this.ba = I.Promise.T.ya; M (isto, I.Promise.T.Ka, b)};
I.Promise.prototype.yl = função (b) {this.ba = I.Promise.T.ya; M (isto, I.Promise.T.na, b)}; função M (b, c, d) {b.ba == I.Promise.T.ya && (b === d && (c = I.Promise.T.na, d = novo TypeError ("Promessa não pode resolver para si mesmo")), b.ba = I .Promise.T.zh, I.Promise.Jg (d, b.xl, b.yl, b) || (b.la = d, b.ba = c, b.ea = null, R (b) , c! = I.Promise.T.na || d instanceof I.Promise.ib || I.Promise.yi (b, d))}}
I.Promise.Jg = function (b, c, d, e) {se (b instanceof I.Promise) retornar I.Promise.Da && L (b, Erro ("then")), Q (b, I.Promise. Bf (c || I.cb, d || null, e)), 0, se (I.Thenable.qg (b)) retornar b.then (c, d, e), 0; se (I .ka (b)) tente {var f = b.then; se (I.Ba (f)) retornar I.Promise.vl (b, f, c, d, e), 0} catch (g) { return d.call (e, g), 0} return! 1}; I.Promise.vl = function (b, c, d, e, f) {função g (b) {l || (l =! 0, e.call (f, b)}} função h (b) {l || (l =! 0, d.call (f, b))} var l =! 1; tente {c.call (b , h, g)} captura (m) {g (m)}}; função R (b) {b.kd || (b.kd =! 0, I.async.O (b.pj, b)) }
função O (b) {var c = nulo; b.Ma && (c = b.Ma, b.Ma = c.next, c.next = null); b.Ma || (b.mb = null); c} I.Promise.prototype.pj = function () {para (var b; b = O (este);) I.Promise.Da && this.lf ++, P (isto, b, this.ba, this.la); this.kd =! 1};
função P (b, c, d, e) {se (d == I.Promise.T.na && c.tb &&! c.bc) if (0 <I.Promise.Wa) para (; b && b.Jc; b = b.ea) I.global.clearTimeout (b.Jc), b.Jc = 0; else if (0 == I.Promise.Wa) para (; b && b.oc; b = b.ea) b.oc = ! 1; se (c.Xa) c.Xa.ea = nulo, I.Promise.lg (c, d, e); senão tente {c.bc? C.Tb.call (c.context): I. Promise.lg (c, d, e)} captura (f) {I.Promise.pc.call (nulo, f)} I.Promise.Sk (c)} I.Promise.lg = função (b, c, d) {c == I.Promise.T.Ka? b.Tb.call (b.context, d): b.tb && b.tb.call (b.contexto, d)};
função L (b, c) {se (I.Promise.Da && I.M (c.stack)) {var d = c.stack.split ("\ n", 4) [3]; c = c.mensagem; c + = Array (11-c.length) .join (""); b.Zd.push (c + d)}} função S (b, c) {se (I.Promise.Da && c && I.M (c.stack ) & for b.Zd.length) {para (var d = ["Promise trace:"], e = e; e = e.ea) {para (var f = b.lf; 0 <= f; f- -) d.push (e.Zd [f]); d.push ("Valor: [" + (e.ba == I.Promise.T.na? "REJEITADO": "CUMPRIDO") + "] < "+ String (e.la) +"> ")} c.stack + =" \ n \ n "+ d.join (" \ n ")}}
I.Promise.yi = funç˜ao (b, c) {0 <I.Promise.Wa? B.Jc = I.global.setTimeout (funç˜ao () {S (b, c); I.Promise.pc.call ( null, c)}, I.Promise.Wa): 0 == I.Promise.Wa && (b.oc =! 0, I.async.O (function () {b.oc && (S (b, c), I.Promise.pc.call (null, c))}))}; I.Promise.pc = I.async.fh; I.Promise.Jt = function (b) {I.Promise.pc = b}; I.Promise.ib = function (b) {I.debug.Error.call (isto, b)}; I. $ a (I.Promise.ib, I.debug.Error); I.Promise.ib.prototype .name = "cancelar"; I.Promise.ai = função (b, c, d) {this.Pg = b; this.resolve = c; this.reject = d};
 Partes deste código são do MochiKit, recebidas por
 The Closure Authors sob a licença do MIT. Todos os outros códigos são direitos autorais
 2005-2009 Os Autores de Encerramento. Todos os direitos reservados.
* /
I.async.B = function (b, c) {this.Fc = []; this.Og = b; this.mf = c || null; this.rb = this.nb =! 1; this.la = void 0; this.Wd = this.Ni = isso. $ c =! 1; this.Ic = 0; this.ea = nulo; this.cc = 0; I.async.B.Da && (this.dd = null , Error.captureStackTrace && (b = {pilha: ""}, Error.captureStackTrace (b, I.async.B), tipo de b.stack == y && (this.dd = b.stack.replace (/ ^ [^ \ n] * \ n /, ""))))}; I.async.B.ki =! 1; I.async.B.Da =! 1; F = I.async.B.prototype;
F.cancel = function (b) {if (this.nb) this.la instância de I.async.B && this.la.cancel (); else {if (this.ea) {var c = this.ea; exclua isso. a; b? c.cancel (b): (c.cc -, 0> = c.cc & c.cancel ())} this.Og? this.Og.call (this.mf, isso): this.Wd =! 0; this.nb || this.Pa (novo I.async.B.hb (this))}}; F.gf = function (b, c) {isto. $ C =! 1; T (isto b, c,} função T (b, c, d) {b.nb =! 0; b.la = d; b.rb =! c; U (b)} função V (b) {se ( b.nb) {se (! b.Wd) lançar novo I.async.B.Ub (b); b.Wd =! 1}} F.Cb = função (b) {V (isto); T (isto , 0, b)}; F.Pa = função (b) {V (isto); W (isto, b); T (isto,! 1, b)};
função W (b, c) {I.async.B.Da && b.dd && I.ka (c) & & c.stack && / ^ [^ \ n] + (\ n [^ \ n] +) + / teste (c. stack) && (c.stack = c.stack + "\ nPRODUÇÃO DEFERIDA: \ n" + b.dd)} função X (b, c, d) {retorno Y (b, c, nulo, d)} função da ( b, c) {Y (b, nulo, c, void 0)} função Y (b, c, d, e) {b.Fc.push ([c, d, e]); b.nb && U (b) return b} F. then = function (b, c, d) {var e f, g = novo I.Promise (função (b, c) {e = b; f = c}); Y (isto, e, function (b) {b instanceof I.async.B.hb? g.cancel (): f (b)}); return g.then (b, c, d)}; I.Thenable.Te (I .async.B);
I.async.B.prototype.Pi = function () {var b = novo I.async.B; Y (isto, b.Cb, b.Pa, b); b.ea = isto; este.cc ++; retorno b); função Z (b) {retorno Ijsome (b.Fc, função (b) {retorno I.Ba (b [1])})}
função U (b) {b.Ic && b.nb && Z (b) && (I.async.B.Dl (b.Ic), b.Ic = 0); b.ea && (b.ea.cc -, excluir b .ea); para (var c = b.la, d =! 1, e =! 1; b.Fc.length &&! b. $ c;) {var f = b.Fc.shift (), g = f [0], h = f [1]; f = f [2]; se (g = b.rb? H: g) tente {var l = g.call (f || b.mf, c); IW (l) && (b.rb = b.rb && (l == c || l instanceof Erro), b.la = c = l); se (I.Thenable.qg (c) || ​​tipoof I.global. Promise === p && c instanceof I.global.Promise) e =! 0, b. $ C =! 0} captura (m) {c = m, b.rb =! 0, W (b, c), Z ( b) || (d =! 0)}} b.la = c; e? (e = I.bind (b.gf, b,! 0), l = I.bind (b.gf, b ,! 1), c exemplo de I.async.B? (Y (c, e, l), c.Ni =! 0):
c.then (e, l)): I.async.B.ki && c instanceof Erro &&! (c instanceof I.async.B.hb) && (d = b.rb =! 0); d && (b.Ic = I .async.B.el (c))} I.async.B.dh = função (b) {var c = novo I.async.B; c.Cb (b); retorno c}; I.async.B .Wq = function (b) {var c = novo I.async.B; b.then (função (b) {c.Cb (b)}, função (b) {c.Pa (b)}); c}; I.async.B.ha = function (b) {var c = novo I.async.B; c.Pa (b); retorno c}; I.async.B.Tp = function () {var b = novo I.async.B; b.cancel (); retorno b};
I.async.B.nu = function (b, c, d) {retornando b instanceof I.async.B? X (b.Pi (), c, d): X (I.async.B.dh (b ), c, d)}; I.async.B.Ub = function () {I.debug.Error.call (este)}; I. $ a (I.async.B.Ub, I.debug.Error I.async.B.Ub.prototype.message = "Adiado já foi acionado"; I.async.B.Ub.prototype.name = "AlreadyCalledError"; I.async.B.hb = function () {I .debug.Error.call (this)}; I. $ a (I.async.B.hb, I.debug.Error); I.async.B.hb.prototype.message = "Adiado foi cancelado"; .async.B.hb.prototype.name = "CanceledError";
I.async.B.xe = function (b) {this.Mb = I.global.setTimeout (I.bind (this.eh, isso), 0); this.nj = b}; I.async.B. xe.prototype.eh = function () {excluir I.async.B.Jb [this.Mb]; throw this.nj;}; I.async.B.Jb = {}; I.async.B.el = function (b) {b = novo I.async.B.xe (b); I.async.B.Jb [b.Mb] = b; retorno b.Mb}; I.async.B.Dl = função ( b) {var c = I.async.B.Jb [b]; c && (I.global.clearTimeout (c.Mb), exclua I.async.B.Jb [b])}; I.async.B. Gp = função () {var b = I.async.B.Jb, c; para (c em b) {var d = b [c]; I.global.clearTimeout (d.Mb); d.eh () }} ID = {}; IDF = {}; IDFUc = "fechamento_verificação"; IDFKh = 5E3; IDFUd = []; IDFal = função (b, c) {função d () {var e = b.shift () ; e = IDFCc (e, c); b.length && Y (e, d, d, void 0); retorne e} if (! b.length) retorne I.async.B.dh (nulo); var e = IDFUd .length; Ijextend (IDFUd, b); se (e) retorna IDFUg; b = IDFUd; IDFUg = d (); retorno IDFUg};
IDFCc = função (b, c) {var d = c || {}; c = d.documento || documento; var e = IbCs (b), f = IacreateElement (k), g = {Vg: f, hh : void 0}, h = novo I.async.B (IDFSi, g), l = nulo, m = l.bb (d.timeout)? d.timeout: IDFKh; 0 <m && (l = window.setTimeout ( function () {IDFec (f,! 0); h.Pa (novo IDFError (IDFWb.TIMEOUT, "Tempo limite atingido para o script de carregamento" + e))}, m), g.hh = l); f.onload = f.onreadystatechange = function () {f.readyState && "carregado"! = f.readyState && "completo"! = f.readyState || (IDFec (f, d. $ p ||! 1, l), h.Cb ( null)); f.onerror = function () {IDFec (f,
! 0, l); h.Pa (novo IDFError (IDFWb.Uh, "Erro ao carregar o script" + e)); g = d.atributos || {}; I.object.extend (g, {type: z, charset: "UTF-8"}); IaGc (f, g); Iail (f, b); IDFHj (c) .appendChild (f); return h};
IDFft = função (b, c, d) {I.global [IDFUC] || (I.global [IDFUC] = {}); var e = I.global [IDFUC], f = IbCs (b); IW (e [c])) return I.async.B.ha (novo IDFError (IDFWb.wi, "Objeto de verificação" + c + "já definido.")); B = IDFCc (b, d); var g = novo I.async.B (I.bind (b.cancel, b)); X (b, função () {var b = e [c]; IW (b)? (g.Cb (b), excluir e [c]): g.Pa (novo IDFError (IDFWb.vi, "Script" + f + "carregado, mas objeto de verificação" + c + "não foi definido."))}); da (b, function (b) { IW (e [c]) && delete e [c]; g.Pa (b)}); return g};
IDFHj = function (b) {var = IagetElementsByTagName ("HEAD", b); return! C || IjQb (c)? D.documentElement: c [0]}; IDFSi = function () {if (this && this.Vg ) {var b = this.Vg; b && b.tagName == k && I.DFec (b,! 0, this.hh)}}; IDFec = função (b, c, d) {I.bb (d) && I.global .clearTimeout (d); b.onload = lcb; b.onerror = lcb; b.onreadystatechange = lcb; c && window.setTimeout (função () {IaremoveNode (b)}, 0)}; IDFWb = {Uh: 0, TIMEOUT: 1, vi: 2, wi: 3};
IDFError = function (b, c) {var d = "erro do Jsloader (código #" + b + ")"; c && (d + = ":" + c); I.debug.Error.call (isto, d); .code = b}; I. $ a (IDFError, I.debug.Error); var google = {G: {}}; google.GJ = {}; google.GJEa = {}; google.GJEa.gh = 3E4; google.GJEa.ws = função (b, c) {retorno {formato: b, Ai: c}}; google.GJEa.Kj = função (b) {retorno IbCformat (b.format, b.Ai)} ; google.GJEa.load = function (b, c) {b = formato_IBC (b, c); var d = IDFCc (b, {tempo: google.GJEa.gh, atributos: {async:! 1, adiar :! 1}}); return new Promise (função (b) {X (d, b)})};
google.GJEa.rs = function (b) {b = Ijmap (b, google.GJEa.Kj); if (IjQb (b)) retorna Promise.resolve (); var c = {timeout: google.GJEa.gh, Atributos: {async:! 1, adiar:! 1}}, d = [];! I.userAgent. $ || I.userAgent.xa (11)? IjforEach (b, funo (b) {d.push ( IDFCc (b, c))}): d.push (IDFal (b, c)); retorno Promise.all (Ijmap (d, função (b) {return new Promise (função (c) {retorno X (b, c)})}))}; google.GJU = {}; if (I.ob (q)) erro de lançamento ("Google Charts loader.js só pode ser carregado uma vez."); google.GJUIl = {1: "1.0", "1.0": "atual", "1.1": "próximo", 41: w, 42: w, 43: w, 44: w, 46: "46.1", anterior: "45.2", atual: "46", a seguir: "46"}; google.GJUEk = function (b) {var = b, d = b.match (/ ^ testing - /); d && (c = c.replace (/ ^ teste- /, "")); b = c; fazer {var e = google.GJUIl [c]; e && (c = e)} enquanto (e);d = (d? "testing -": "") + c; return {versão: c == w? b: d, xk: d}}; google.GJUnh = nulo;
google.GJUwk = function (b) {var = google.GJUEk (b), d = IfHfrom ("https://www.gstatic.com/charts/%{version}/loader.js"); retorne o google. GJEa.load (d, {versão: c.xk}). Então (function () {var d = I.ob ("google.charts.loader.VersionSpecific.load") || I.ob ("google.charts .loader.publicLoad ") || I.ob (" google.charts.versionSpecific.load "); if (! d) erro de lançamento (" Versão inválida: "+ b); google.GJUnh = função (b) {b = d (c.version, b); if (null == b || null == b.then) {var e = I.ob ("google.charts.loader.publicSetOnLoadCallback") || I.ob (" google.charts.versionSpecific.setOnLoadCallback ");
b = new Promise (função (b) {e (b)}); b.then = e} retornar b}})}; google.GJULd = null; google.GJUgc = null; google.GJUuk = função (b, c) {google.GJULd || (google.GJULd = google.GJUwk (b)); retorno google.GJUgc = google.GJULd.then (function () {retorno google.GJUnh (c)})}; google.GJUhl = function (b) {if (! google.GJUgc) erro de lançamento ("Deve chamar google.charts.load antes de google.charts.setOnLoadCallback"); retornar b? google.GJUgc.then (b): google.GJUgc};
google.G.load = function (b) {para (var c = [], d = 0; d <argumentos.length; ++ d) c [d-0] = argumentos [d]; d = 0; " visualização "=== c [d] && d ++; var e =" atual "; IM (c [d]) && (e = c [d], d ++); var f = {}; I.ka (c [d ]) && (f = c [d]); retorno google.GJUuk (e, f)}; I.qf (q, google.G.load); google.G.gl = google.GJUhl; I.qf ( "google.charts.setOnLoadCallback", google.G.gl);}). call (this);